<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php+redis实现二叉树的存储和遍历]]></title>
    <url>%2F2019%2F03%2F19%2F18.php%2Bredis%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com github地址：https://github.com/jian1098/php-redis-binary-tree 二叉树是软件开发过程中很常见的数据结构，本文通过php进行二叉树的生成和遍历，通过redis将二叉树存储，也可以将redis换成其他的关系型数据库，但是读写速度嘛是差挺远的。代码中有足够的注释，应该不难懂，仅供参考和学习。 首先封装二叉树的生成和遍历算法 tree.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?php// 节点类Class BTNode&#123; public $data; public $lChild; public $rChild; public function __construct($data = null) &#123; $this-&gt;data = $data; &#125;&#125;// 二叉树类Class BinaryTree&#123; public $btData; public function __construct($data = null) &#123; $this-&gt;btData = $data; &#125; //创建二叉树 public function CreateBT(&amp;$root = null) &#123; $elem = array_shift($this-&gt;btData); if ($elem == null) &#123; return 0; &#125; else if ($elem == &apos;#&apos;) &#123; $root = null; &#125; else &#123; $root = new BTNode(); $root-&gt;data = $elem; $this-&gt;CreateBT($root-&gt;lChild); $this-&gt;CreateBT($root-&gt;rChild); &#125; return $root; &#125; //先序遍历二叉树 public function PreOrder($root) &#123; if ($root != null) &#123; echo $root-&gt;data . &quot; &quot;; $this-&gt;PreOrder($root-&gt;lChild); $this-&gt;PreOrder($root-&gt;rChild); &#125; else &#123; return; &#125; &#125; //中序遍历二叉树 public function InOrder($root) &#123; if ($root != null) &#123; $this-&gt;InOrder($root-&gt;lChild); echo $root-&gt;data . &quot; &quot;; $this-&gt;InOrder($root-&gt;rChild); &#125; else &#123; return; &#125; &#125; //后序遍历二叉树 public function PosOrder($root) &#123; if ($root != null) &#123; $this-&gt;PosOrder($root-&gt;lChild); $this-&gt;PosOrder($root-&gt;rChild); echo $root-&gt;data . &quot; &quot;; &#125; else &#123; return; &#125; &#125; //层序(广度优先)遍历二叉树 function LeverOrder($root) &#123; $queue = new SplQueue();//双向链表 if ($root == null)&#123; return; &#125;else&#123; $queue-&gt;enqueue($root); &#125; while (!$queue-&gt;isEmpty()) &#123; $node = $queue-&gt;bottom(); $queue-&gt;dequeue(); echo $node-&gt;data . &quot; &quot;; if ($node-&gt;lChild)&#123; $queue-&gt;enqueue($node-&gt;lChild); &#125;else&#123;// echo $node-&gt;data.&apos;的左子树为空&apos;; &#125; if ($node-&gt;rChild)&#123; $queue-&gt;enqueue($node-&gt;rChild); &#125;else&#123;// echo $node-&gt;data.&apos;的右子树为空&apos;; &#125; &#125; &#125;&#125; 接着封装操作redis的类 redis.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpclass MyRedis &#123; private $redis; private $host; //redis ip private $port; //redis 端口 private $tree; public function __construct($host,$port)&#123; $this-&gt;host=$host; $this-&gt;port=$port; //连接redis if(class_exists(&apos;Redis&apos;))&#123; $this-&gt;redis = new \Redis(); if($this-&gt;redis-&gt;connect($this-&gt;host, $this-&gt;port))&#123; $this-&gt;connect=true; &#125; &#125;else&#123; exit(&apos;redis扩展不存在&apos;); &#125; &#125; //添加节点 public function addNode($id,$data)&#123; if(!is_array($data))&#123; return []; &#125; $resOrder=$this-&gt;redis-&gt;hMSet($id,$data); return $resOrder; &#125; //查找节点 public function getNode($id)&#123; return $this-&gt;redis-&gt;hGetAll($id); &#125; //修改指定节点的属性 public function setNode($id,$field,$value)&#123; return $this-&gt;redis-&gt;hSet($id,$field,$value); &#125; //获取redis所有键 public function getKeys()&#123; return $this-&gt;redis-&gt;keys(&apos;*&apos;); &#125; //获取key的个数 public function dbSize()&#123; return $this-&gt;redis-&gt;dbSize(); &#125; //清空数据库 public function flushDB()&#123; return $this-&gt;redis-&gt;flushDB(); &#125; //前序遍历的顺序取出二叉树 public function tree($root_id)&#123; $rootNode=$this-&gt;getNode($root_id); $this-&gt;tree[]=$root_id; if (isset($rootNode[&apos;left&apos;]))&#123; $this-&gt;tree($rootNode[&apos;left&apos;]); &#125; if (isset($rootNode[&apos;right&apos;]))&#123; $this-&gt;tree($rootNode[&apos;right&apos;]); &#125; return $this-&gt;tree; &#125;&#125; 最后调用两个类进行二叉树的存取和遍历 index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phprequire_once &apos;redis.php&apos;;require_once &apos;tree.php&apos;;$myredis=new MyRedis(&apos;127.0.0.1&apos;,&apos;6379&apos;);/* 假设我构造一颗如下的二叉树 1 2 3 # 4 # # # #*///添加节点//$data=[// &apos;left&apos; =&gt; &apos;2&apos;,// &apos;right&apos; =&gt; &apos;3&apos;,//];//$res=$myredis-&gt;addNode(1,$data);////$data=[// &apos;left&apos; =&gt; &apos;#&apos;,// &apos;right&apos; =&gt; &apos;4&apos;,//];//$res=$myredis-&gt;addNode(2,$data);////$data=[// &apos;left&apos; =&gt; &apos;#&apos;,// &apos;right&apos; =&gt; &apos;#&apos;,//];//$res=$myredis-&gt;addNode(3,$data);////$data=[// &apos;left&apos; =&gt; &apos;#&apos;,// &apos;right&apos; =&gt; &apos;#&apos;,//];//$res=$myredis-&gt;addNode(4,$data);//print_r($res);//修改节点信息//$res=$myredis-&gt;setNode(1,&apos;left&apos;,2);//print_r($res);//查询指定节点//$res=$myredis-&gt;getNode(1);//print_r($res);//清空数据//$res=$myredis-&gt;flushDB();//获取redis所有键//$res=$myredis-&gt;getKeys();//print_r($res);//前序遍历的顺序从redis读取节点$data=$myredis-&gt;tree(1);//$data = array(1,2,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,3,&apos;#&apos;,&apos;#&apos;);//生成二叉树$tree = new BinaryTree($data);$root = $tree-&gt;CreateBT();//遍历二叉树echo &apos;前序：&apos;;$tree-&gt;PreOrder($root);echo &apos;&lt;br&gt;中序：&apos;;$tree-&gt;InOrder($root);echo &apos;&lt;br&gt;后序：&apos;;$tree-&gt;PosOrder($root);echo &apos;&lt;br&gt;层序：&apos;;$tree-&gt;LeverOrder($root); 执行结果 1234前序：1 2 4 3 中序：2 4 1 3 后序：4 2 3 1 层序：1 2 3 4]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Supervisor实现Linux守护进程]]></title>
    <url>%2F2019%2F02%2F28%2F17.%E4%BD%BF%E7%94%A8Supervisor%20%E5%AE%9E%E7%8E%B0Linux%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com 前言做过系统软件开发的人都会遇到，如果写好的程序需要在Linux后台运行时不太好处理，用nohup和&amp;放到后台的话，很难对线程进行停止和重启操作。Supervisor (http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的实现启动、重启、关闭进程、意外停止自动重启、日志分割等功能。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动，同时Supervisor 提供web管理页面可以进行远程管理，非常方便。 安装supervisorCentos 123[root@ztg ~]# yum install epel-release #如果已经有python环境可以跳过前两步[root@ztg ~]# yum install -y python-pip[root@ztg ~]# pip install supervisor Ubuntu 1[root@ztg ~]# apt-get install supervisor 配置supervisor生成配置文件 1[root@ztg ~]# echo_supervisord_conf &gt; /etc/supervisord.conf 如果出现下面的错误 12345678910Traceback (most recent call last): File &quot;/usr/bin/supervisord&quot;, line 5, in &lt;module&gt; from pkg_resources import load_entry_point File &quot;/usr/lib/python2.6/site-packages/pkg_resources.py&quot;, line 2655, in &lt;module&gt; working_set.require(__requires__) File &quot;/usr/lib/python2.6/site-packages/pkg_resources.py&quot;, line 648, in require needed = self.resolve(parse_requirements(requirements)) File &quot;/usr/lib/python2.6/site-packages/pkg_resources.py&quot;, line 546, in resolve raise DistributionNotFound(req)pkg_resources.DistributionNotFound: meld3&gt;=0.6.5 请以此执行下面4行命令再生成配置文件 1234[root@ztg ~]# wget https://pypi.python.org/packages/source/m/meld3/meld3-1.0.2.tar.gz[root@ztg ~]# tar -zxf meld3-1.0.2.tar.gz[root@ztg ~]# cd meld3-1.0.2[root@ztg ~]# python setup.py install 编辑/etc/supervisord.conf，在最后增加要自定义运行程序的配置信息：（举例的httpserver是用golang实现的简单的http服务程序） 1[root@ztg ~]# vi /etc/supervisord.conf 12345678910111213[program:httpserver]command=/bin/bash -c &quot;/home/ztg/httpserver&quot;autostart=trueautorestart=truestartsecs=10stdout_logfile=/var/log/go_http_server_info.logstdout_logfile_maxbytes=2MBstdout_logfile_backups=30stdout_capture_maxbytes=2MBstderr_logfile=/var/log/go_http_server_error.logstderr_logfile_maxbytes=2MBstderr_logfile_backups=30stderr_capture_maxbytes=2MB 配置说明 12345678910111213[program:程序名]command=/bin/bash -c &quot;需要执行的命令，多句命令用分号隔开&quot;autostart=true 是否跟随supervisor一起启动autorestart=true 如果该程序挂了，是否重新启动startsecs=10stdout_logfile=/var/log/go_http_server_info.log 终端标准输出重定向文件stdout_logfile_maxbytes=2MB 文件最大大小stdout_logfile_backups=30 文件备份最大数量stdout_capture_maxbytes=2MB stderr_logfile=/var/log/go_http_server_error.log 终端错误输出重定向文件stderr_logfile_maxbytes=2MBstderr_logfile_backups=30stderr_capture_maxbytes=2MB 操作supervisor启动supervisor，使用默认配置文件： 1$ supervisord 或者指定配置文件： 1$ /usr/bin/supervisord -c /etc/supervisord.conf 启动supervisor之后可以执行supervisorctl相关命令 supervisorctl 常用命令： 命令 说明 supervisorctl stop program_name 停止某个进程 supervisorctl start program_name 启动某个进程 supervisorctl restart program_name 重启某个进程 supervisorctl stop all 停止全部进程 supervisorctl reload 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程 supervisorctl update 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启 查看运行状态并进入控制台，在控制台中执行命令可以省去supervisorctl命令 1234$ supervisorctlhttpserver RUNNING pid 34236, uptime 0:00:28supervisor&gt; stop httpserverhttpserver: stopped Web管理页面supervisor提供了可视化的Web管理页面，允许远程操作，但是需要在配置文件手动打开。 打开配置文件 1$ vi /etc/supervisord.conf 将下面几行前面的分号去掉，修改一下数据保存退出 1234[inet_http_server] ; HTTP 服务器，提供 web 管理界面port=192.168.1.194:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性username=user ; 登录管理后台的用户名password=123 ; 登录管理后台的密码 重新载入配置 1$ supervisorctl reload 在浏览器打开刚刚配置的ip和端口（192.168.1.194:9001）即可弹出登录框进入管理页面。 查看日志访问配置文件中定义的日志文件即可 12$ tail -f /var/log/go_http_server_info.log$ tail -f /var/log/go_http_server_error.log]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Supervisor</tag>
        <tag>守护进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下EOS测试环境(私有链)搭建]]></title>
    <url>%2F2019%2F01%2F10%2F15.Ubuntu%E4%B8%8BEOS%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83(%E7%A7%81%E6%9C%89%E9%93%BE)%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com 环境要求 Ubuntu 16.04 内存4G以上（官方要求8G，可以通过修改文件降低要求） 编译安装clone源码 1jian@ubuntu:~$ git clone https://github.com/eosio/eos.git --recursive 需要注意的是，MongoDB是EOS的依赖项之一，而在墙内下载该依赖项会失败，请先科学上网，再开始编译，否则会无法下载MongoDB导致编译失败。 编译 12jian@ubuntu:~$ cd eosjian@ubuntu:~/eos$ sudo ./eosio_build.sh #需要3个小时左右，遇到错误请往下看 如果提示下面的信息，说明内存达不到要求，至少需要7G以上内存空间 123......Your system must have 7 or more Gigabytes of physical memory installed.Exiting now. 将VMware的内存增加到4G多一点，记住要多一点，然后修改./scripts/eosio_build_ubuntu.sh文件,查找7000，将7000修改为4000即可，意思是将配置要求降低到4G内存。 如果看到下面的5个红色大字表示已经编译完成了，除开填坑的时间花了整整4个小时。 1234567891011121314151617181920212223242526[100%] Built target print_floats _______ _______ _______ _________ _______ ( ____ \( ___ )( ____ \\__ __/( ___ ) | ( \/| ( ) || ( \/ ) ( | ( ) | | (__ | | | || (_____ | | | | | | | __) | | | |(_____ ) | | | | | | | ( | | | | ) | | | | | | | | (____/\| (___) |/\____) |___) (___| (___) | (_______/(_______)\_______)\_______/(_______) EOSIO has been successfully built. 00:38:51 To verify your installation run the following commands: export PATH=$&#123;HOME&#125;/opt/mongodb/bin:$PATH /home/jian/opt/mongodb/bin/mongod -f /home/jian/opt/mongodb/mongod.conf &amp; cd /home/jian/eos/build; make test For more information: EOSIO website: https://eos.io EOSIO Telegram channel @ https://t.me/EOSProject EOSIO resources: https://eos.io/resources/ EOSIO Stack Exchange: https://eosio.stackexchange.com EOSIO wiki: https://github.com/EOSIO/eos/wiki 编译完成后安装 12jian@ubuntu:~/eos$ cd buildjian@ubuntu:~/eos/build$ sudo make install 在./programs这个文件夹中可以找到eos的几个核心程序 nodeos： 区块链服务器节点生成组件。nedeos的配置文件位于~/Library/Application Support/eosio/nodeos/config文件夹中，区块数据存储在文件~/Library/Application Support/eosio/nodeos/data中 cleos： 和区块链交互的接口命令 keosd： EOS 钱包，作用是存储私钥，以便cleos用以签署交易并发送到区块链中。keosd在本机运行，并且将私钥存储在本地。keosd会随着cleos自动启动。 eosio-launcher：节点网络组成和部署的应用 启动节点12jian@ubuntu:~/eos/build$ cd ~/eos/build/programs/nodeosjian@ubuntu:~/eos/build/programs/nodeos$ sudo ./nodeos -e -p eosio -d /data/eos --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --plugin eosio::bnet_plugin --contracts-console --filter-on &quot;*&quot; --access-control-allow-origin &quot;*&quot; --max-transaction-time=1000 --verbose-http-errors 参数说明： -p：表示使用了 本地测试系统提供的原始账户 eosio 账户的权限 -d：区块数据存放目录 –plugin：插件 -e：开启Stale Production，即即便当前时间已经超过规定的区块生产时限，也继续产生 –plugin eosio::chain_api_plugin：开启区块链JSON API插件。 –plugin eosio::history_api_plugin：开启历史数据插件，有了这个插件，便能查询许多不在State中的数据，譬如一个公钥所对应的所有账户等等。 –contracts-console：开启合约控制台。如果不开启的话，合约中调用print函数输出的信息将会不可见。 –filter-on “*”：开启所有账户的历史纪录。默认状态下，节点不会记录账户的历史数据，从而使得命令cleos get actions返回空。 –access-control-allow-origin “*”：允许任意域名跨域访问API，如果不开启，在dApp开发中，网站会报错。 上面的启动命令比较长，可以将参数写入配置文件 12jian@ubuntu:~/eos/build/programs/cleos$ cd ~/.local/share/eosio/nodeos/configjian@ubuntu:~/.local/share/eosio/nodeos/config$ vi config.ini 修改或新增以下内容： 1234567891011121314# 下面是修改的 enable-stale-production = true # 修改false为true filter-on = * producer-name = eosio # 下面的插件是新增的，加在文件最后 # Load the block producer plugin, so you can produce blocks plugin = eosio::producer_plugin # As well as API and HTTP plugins plugin = eosio::chain_api_plugin plugin = eosio::http_plugin # This will be used by the validation step below, to view history plugin = eosio::history_api_plugin plugin = eosio::bnet_plugin 然后启动节点 12jian@ubuntu:~/eos/build$ cd ~/eos/build/programs/nodeosjian@ubuntu:~/eos/build/programs/nodeos$ sudo ./nodeos 停止节点按下Ctrl+C即可停止节点 导入私钥首先我们需要创建一个默认的钱包，请记住的到的私钥 1234567jian@ubuntu:~$ cd ~/eos/build/programs/cleosjian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet create --to-console&quot;/home/jian/eos/build/programs/keosd/keosd&quot; launchedCreating wallet: defaultSave password to use in the future to unlock this wallet.Without password imported keys will not be retrievable.&quot;PW5JXUScSE7QnskHEjuwXBVwfYnjozaHFC6MA4ouDrLX9L7XZNkzF&quot; 这里创建了钱包名为default，密码为”PW5JXUScSE7QnskHEjuwXBVwfYnjozaHFC6MA4ouDrLX9L7XZNkzF”的钱包。 打开钱包看看有什么内容 (如果钱包已经锁定，需要先解锁钱包)： 1234jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet keys[ &quot;EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;] 可以看到新创建的钱包中有一个密钥对，这是唯一的初始帐户eosio的主密钥对，不要将上述主密钥与你将来添加的密钥混淆。 进入配置文件 12jian@ubuntu:~/eos/build/programs/cleos$ cd ~/.local/share/eosio/nodeos/configjian@ubuntu:~/.local/share/eosio/nodeos/config$ vi config.ini 找到这一行 1signature-provider = EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV=KEY:5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 这是指定了默认区块产生者eosio的公私钥对，其中公钥为：EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 相对应的私钥为：5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 为什么钱包中已经有密钥对了还要再添加？ 每个EOS帐户都拥有owner(所有者)和active(活动权限)两个权限，因此，在大多数情况下，需要创建两个密钥，以便可以将一个密钥与每个权限相关联。 首先创建两个密钥对 12345678jian@ubuntu:~$ cd ~/eos/build/programs/cleosjian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos create key --to-consolePrivate key: 5JxhYZZnFJJMRrf7KkSHNLFq2LM4eZigJfeKXXYSa1TvPMdWtLcPublic key: EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDtjian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos create key --to-consolePrivate key: 5JXNT5zRfFDwzc7mKmd3AiYjT9dvfDosiFAo1drkneY6TrhTRUpPublic key: EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa 然后依次将两个Private key导入到创建的默认钱包中 1234jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet import --private-key 5JxhYZZnFJJMRrf7KkSHNLFq2LM4eZigJfeKXXYSa1TvPMdWtLcimported private key for: EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDtjian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet import --private-key 5JXNT5zRfFDwzc7mKmd3AiYjT9dvfDosiFAo1drkneY6TrhTRUpimported private key for: EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa 可以看到导入私钥后会自动给出对应的公钥。 在次打开默认钱包可以看到默认钱包中已经有3个密钥对了 123456jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet keys[ &quot;EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt&quot;, &quot;EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;, &quot;EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa&quot;] 发行代币在部署eosio.EOStem合约之前，必须先创建如下账户，创建账号使用eosio的公私钥对： 1234567891011EOStemAccounts = [ &apos;eosio.bpay&apos;, &apos;eosio.msig&apos;, &apos;eosio.names&apos;, &apos;eosio.ram&apos;, &apos;eosio.ramfee&apos;, &apos;eosio.saving&apos;, &apos;eosio.stake&apos;, &apos;eosio.token&apos;, &apos;eosio.upay&apos;,] 创建命令如下： 123456789sudo ./cleos create account eosio eosio.bpay EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.msig EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.names EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.ram EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.ramfee EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.saving EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.stake EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV;sudo ./cleos create account eosio eosio.upay EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV; 执行的结果如下： 1234executed transaction: 9da6a67895e9efc1a794e4beae1f8134e6a3a0e866a5092cdfb55f77b7642c5d 200 bytes 192 us# eosio &lt;= eosio::newaccount &#123;&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;eosio.upay&quot;,&quot;owner&quot;:&#123;&quot;threshold&quot;:1,&quot;keys&quot;:[&#123;&quot;key&quot;:&quot;EOS6MRyAjQq8ud7hVNYcfn...warn 2018-11-28T03:33:33.304 thread-0 main.cpp:482 print_resuwarning: transaction executed locally, but may not be confirmed by the network yet...... 接下来将代币合约部署到eosio.token账户中： 12345678910jian@ubuntu:~/eos/build/programs/cleos$ cd ~/eos/build/contracts # 进入编译后的合约目录jian@ubuntu:~/eos/build/contracts$ sudo ~/eos/build/programs/cleos/cleos set contract eosio.token ./eosio.token#执行结果：Reading WASM from ./eosio.token/eosio.token.wasm...Publishing contract...executed transaction: 69b358aab5d199797aa8165b5969646881aed401ea03b2b6def43affdd183f3e 8104 bytes 27919 us# eosio &lt;= eosio::setcode &#123;&quot;account&quot;:&quot;eosio.token&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d01000000017e1560037f7e7f0060057f7e...# eosio &lt;= eosio::setabi &#123;&quot;account&quot;:&quot;eosio.token&quot;,&quot;abi&quot;:&quot;0e656f73696f3a3a6162692f312e30010c6163636f756e745f6e616d65046e616d65...warn 2018-11-28T03:41:50.674 thread-0 main.cpp:482 print_resuwarning: transaction executed locally, but may not be confirmed by the network yet 创建1亿个EOS代币（这里的EOS币相当于主网中的EOS）： 123456jian@ubuntu:~/eos/build/contracts$ sudo ~/eos/build/programs/cleos/cleos push action eosio.token create &apos;[&quot;eosio&quot;,&quot;10000000000.0000 SYS&quot;,0,0,0]&apos; -p eosio.token#执行结果：executed transaction: cb0973dfa4a52dd0c99ef56834c84d391dda565a4aeeafaaafaef5642190f4e4 120 bytes 1436 us# eosio.token &lt;= eosio.token::create &#123;&quot;issuer&quot;:&quot;eosio&quot;,&quot;maximum_supply&quot;:&quot;100000000.0000 EOS&quot;&#125;warn 2018-11-28T03:44:50.857 thread-0 main.cpp:482 print_resuwarning: transaction executed locally, but may not be confirmed by the network yet 发行代币，数量：10000000000，代币符号：EOS。 123456jian@ubuntu:~/eos/build/contracts$ sudo ~/eos/build/programs/cleos/cleos push action eosio.token issue &apos;[&quot;eosio&quot;,&quot;10000000000.0000 EOS&quot;,&quot;issue&quot;]&apos; -p eosio# 执行结果executed transaction: 59f8a3fe587335f5c3ebdd12ac7a39f638cf028966a6efa2250f1244e82f178d 128 bytes 1288 us# eosio.token &lt;= eosio.token::issue &#123;&quot;to&quot;:&quot;eosio&quot;,&quot;quantity&quot;:&quot;10000000000.0000 EOS&quot;,&quot;memo&quot;:&quot;memo&quot;&#125;warn 2018-11-28T03:54:16.092 thread-0 main.cpp:482 print_resuwarning: transaction executed locally, but may not be confirmed by the network yet 查询代币数量 123jian@ubuntu:~/eos/build/contracts$ sudo ~/eos/build/programs/cleos/cleos get currency balance eosio.token eosio10000000000.0000 EOS 创建账号在EOS中，为了控制权限，创建账号是需要指定一个创建者的，例如默认钱包的创建者是eosio，所以创建default账号中含有eosio的私钥。 创建账户的格式如下： 1cleos create account AUTHORIZING_ACCOUNT NEW_ACCOUNT OWNER_KEY ACTIVE_KEY authorizing_account 是新账户的创建者。在此教程中，由于我们运行的是一个单节点测试网络，所以我们拥有一个名为eosio的系统账户，因此我们使用eosio作为新账户的创建者 new_account 是要创建的账户名称 owner_key 是账户owner权限的公钥 active_key 是账户active权限的公钥 我们使用account1作为新账户名称，使用eosio作为新账户的创建者，使用之前生成并导入default钱包的两个公钥EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt和EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa分别作为owner权限和active权限的公钥，注意这里是使用公钥！！！ 1jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos create account eosio account1 EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa 我这里报错了,因为交易是需要RAM资源的。如果没有报错请忽略下面一步。 123Error 3080001: Account using more than allotted RAM usageError Details:account account1 has insufficient ram; needs 2996 bytes has 0 bytes 将创建命令改为下面的才能成功 12345678910111213jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos system newaccount eosio account1 EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa --stake-net &apos;0 EOS&apos; --stake-cpu &apos;0 EOS&apos; --buy-ram-kbytes 3 -x 30executed transaction: 5171d92b16934b8a773a57e617aba5443f5394551cba376eb2d61788ea7460b4 248 bytes 1448 us# eosio &lt;= eosio::newaccount &#123;&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;account1&quot;,&quot;owner&quot;:&#123;&quot;threshold&quot;:1,&quot;keys&quot;:[&#123;&quot;key&quot;:&quot;EOS5Fwtc4vnQE8AigimXvHrE...# eosio &lt;= eosio::buyrambytes &#123;&quot;payer&quot;:&quot;eosio&quot;,&quot;receiver&quot;:&quot;account1&quot;,&quot;bytes&quot;:3072&#125;# eosio.token &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ram&quot;,&quot;quantity&quot;:&quot;0.4447 SYS&quot;,&quot;memo&quot;:&quot;buy ram&quot;&#125;# eosio &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ram&quot;,&quot;quantity&quot;:&quot;0.4447 SYS&quot;,&quot;memo&quot;:&quot;buy ram&quot;&#125;# eosio.ram &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ram&quot;,&quot;quantity&quot;:&quot;0.4447 SYS&quot;,&quot;memo&quot;:&quot;buy ram&quot;&#125;# eosio.token &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ramfee&quot;,&quot;quantity&quot;:&quot;0.0023 SYS&quot;,&quot;memo&quot;:&quot;ram fee&quot;&#125;# eosio &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ramfee&quot;,&quot;quantity&quot;:&quot;0.0023 SYS&quot;,&quot;memo&quot;:&quot;ram fee&quot;&#125;# eosio.ramfee &lt;= eosio.token::transfer &#123;&quot;from&quot;:&quot;eosio&quot;,&quot;to&quot;:&quot;eosio.ramfee&quot;,&quot;quantity&quot;:&quot;0.0023 SYS&quot;,&quot;memo&quot;:&quot;ram fee&quot;&#125;warn 2018-12-05T10:49:19.302 thread-0 main.cpp:482 print_resuwarning: transaction executed locally, but may not be confirmed by the network yet 查询刚刚创建的账号： 1234567891011121314151617181920jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos get account account1created: 2018-12-05T10:49:19.500permissions: owner 1: 1 EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt active 1: 1 EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoamemory: quota: 2.982 KiB used: 2.926 KiB net bandwidth: delegated: 0.0000 SYS (total staked delegated to account from others) used: 0 bytes available: 0 bytes limit: 0 bytescpu bandwidth: delegated: 0.0000 SYS (total staked delegated to account from others) used: 0 us available: 0 us limit: 0 us 锁定钱包12jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet lock -n jianLocked: jian keosd会在没有钱包指令的15分钟后自动锁定钱包，可以在~/eosio-wallet/config.ini中进行时长修改。可以设置一个超大数来取消这项功能。如果设为0，将会导致钱包永久锁定。 解锁钱包没有-n指定钱包名会解锁默认钱包，默认钱包解锁密码是”导入私钥”中创建钱包时得到的PW开头的私钥 12jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet unlock -n jianpassword: Unlocked: jian 再次查看钱包，可以看到有*号表示已经解锁了 123456jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos wallet listWallets:[ &quot;default&quot;, &quot;jian *&quot;] 发送交易转100个币到account1账号中 1jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos push action eosio.token transfer &apos;[&quot;eosio&quot;, &quot;account1&quot;,&quot;100.0000 EOS&quot;,&quot;memo&quot;]&apos; -p eosio 查询account1账号的余额 12jian@ubuntu:~/eos/build/programs/cleos$ sudo ./cleos get currency balance eosio.token account1100.0000 EOS 参考文章https://www.jianshu.com/nb/24907261 https://zhuanlan.zhihu.com/p/40009564 https://blog.csdn.net/littlefool5201314/article/details/79869114 https://www.jianshu.com/p/13c7bddacfd9 https://www.bcskill.com/index.php/archives/21.html]]></content>
      <categories>
        <category>EOS</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>EOS测试环境</tag>
        <tag>EOS私有链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下go语言环境搭建]]></title>
    <url>%2F2019%2F01%2F03%2F11.Ubuntu%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com 安装程序1jian@ubuntu:~$ sudo apt-get install golang-go 安装完成查看版本 12jian@ubuntu:~$ go versiongo version go1.10.4 linux/amd64 配置环境12jian@ubuntu:~$ mkdir go #创建项目目录jian@ubuntu:~$ vi .bashrc 将下面的GOPATH路径修改为你的项目路径，然后将3条命令添加到文件的最后，保存 123export GOPATH=/home/jian/goexport GOBIN=$GOPATH/binexport PATH=$PATH:$&#123;GOPATH//://bin:&#125;/bin 执行下面的命令使环境变量生效 1jian@ubuntu:~$ source ~/.bashrc 查看配置好的go环境变量 12345678910111213141516171819202122232425jian@ubuntu:~$ go envGOARCH=&quot;amd64&quot;GOBIN=&quot;/home/jian/go/bin&quot;GOCACHE=&quot;/home/jian/.cache/go-build&quot;GOEXE=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;linux&quot;GOOS=&quot;linux&quot;GOPATH=&quot;/home/jian/go&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/lib/go-1.10&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/usr/lib/go-1.10/pkg/tool/linux_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;gcc&quot;CXX=&quot;g++&quot;CGO_ENABLED=&quot;1&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build276791919=/tmp/go-build -gno-record-gcc-switches&quot; 编写项目创建目录 1234jian@ubuntu:~$ cd go #进入项目目录jian@ubuntu:~/go$ mkdir bin #存放go install 编译安装之后生成的可执行文件会在这个目录中jian@ubuntu:~/go$ mkdir pkg #存放go build 编译生成的库文件jian@ubuntu:~/go$ mkdir src #源代码目录 编写main.go 12jian@ubuntu:~/go$ cd srcjian@ubuntu:~/go/src$ vi main.go 将下面的hello world代码保存 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 执行程序 12jian@ubuntu:~/go/src$ go run main.goHello, World! 编译程序 1jian@ubuntu:~/go/src$ go build main.go 可视化编辑器推荐的编辑器有GoLand和Sublime GoLand下载压缩包：https://www.jetbrains.com/go/download/#section=linux 解压 1jian@ubuntu:~/Desktop$ tar -zxzf goland-2018.3.2.tar.gz 启动 12jian@ubuntu:~/Desktop$ cd GoLand-2018.3.2/binjian@ubuntu:~/Desktop/GoLand-2018.3.2/bin$ ./goland.sh 打开上面编写的项目即可 Sublime依次执行下面的命令进行安装 12345jian@ubuntu:~$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -jian@ubuntu:~$ sudo apt-get install apt-transport-httpsjian@ubuntu:~$ echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.listjian@ubuntu:~$ sudo apt-get updatejian@ubuntu:~$ sudo apt-get install sublime-text 安装完成后可以在应用程序列表中找到Sublime的图标，点击即可启动]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>go语言</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下USDT测试环境搭建]]></title>
    <url>%2F2018%2F12%2F29%2F14.Ubuntu%E4%B8%8BUSDT%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com 关于USDT泰达币（USDT）是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（下称USDT），1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether 公司严格遵守1：1的准备金保证，即每发行1个 USDT 代币，其银行账户都会有1美元的资金保障。用户可以在 Tether 平台进行资金查询，以保障透明度。 Omni Layer是一种通信协议，它使用比特币区块链实现智能合约，用户货币和分散式点对点交换等功能。 Omni Core是基于比特币核心代码库的快速，便携式Omni层实现。 这种实现不需要与Bitcoin Core无关的外部依赖关系，并且与其他比特币节点一样，它本身就是比特币网络。 它目前支持钱包模式，并可在三种平台上无缝使用：Windows，Linux和Mac OS。 Omni Layer扩展通过JSON-RPC接口公开。 Tether的钱包是以bitcoin区块网络为基础的，在这个网络上面搭建了名为Omni Layer的共识网络，其主要的思想是对bitcoin的区块进行染色，写入需要存储的数据。 安装omnicore程序123jian@ubuntu:/root# wget https://github.com/OmniLayer/omnicore/releases/download/v0.3.1/omnicore-0.3.1-x86_64-linux-gnu.tar.gzjian@ubuntu:/root# tar -zvxf omnicore-0.3.1-x86_64-linux-gnu.tar.gz jian@ubuntu:/root# sudo install -m 0755 -o root -g root -t /usr/local/bin ./omnicore-0.3.1/bin/* 配置bitcoin参数1234jian@ubuntu:~$ mkdir .bitcoin #创建主目录,如果目录已经存在请跳过jian@ubuntu:~$ mkdir omnidata #创建区块数据目录jian@ubuntu:~$ cd .bitcoin/jian@ubuntu:~/.bitcoin$ vi bitcoin.conf 将下面信息全部复制，并修改rpcuser（RPC用户名），rpcpassword（RPC用户密码），rpcallowip（允许访问的ip地址）然后保存 1234567891011121314151617181920212223242526# Generated by https://jlopp.github.io/bitcoin-core-config-generator/# This config should be placed in following path:# ~/.bitcoin/bitcoin.conf# [rpc]# Accept command line and JSON-RPC commands.server=1# Username for JSON-RPC connectionsrpcuser=omnicorerpc# Password for JSON-RPC connectionsrpcpassword=omnicorerpc# Listen for JSON-RPC connections on this portrpcport=18332# Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), # a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option # can be specified multiple times.cd /usrrpcallowip=192.168.1.174rpcallowip=192.168.1.179# Run this node on the litecoin Test Network.testnet=1 启动omnicore程序请将-conf和-datadir 路径修改为你的路径 1jian@ubuntu:~/.omni$ omnicored -conf=/home/jian/.bitcoin/bitcoin.conf -datadir=/home/jian/omnidata -txindex=1 -daemon 1234567892018-11-22 10:46:09 Loading trades database: OK2018-11-22 10:46:09 Loading send-to-owners database: OK2018-11-22 10:46:09 Loading tx meta-info database: OK2018-11-22 10:46:09 Loading smart property database: OK2018-11-22 10:46:09 Loading master transactions database: OK2018-11-22 10:46:09 Loading fee cache database: OK2018-11-22 10:46:09 Loading fee history database: OK2018-11-22 10:46:09 Loading persistent state: NONE (no usable previous state found)2018-11-22 10:46:09 Omni Core initialization completed 初始化两分钟后再查看是否启动成功，要不然不会输出任何信息，需要输入上一步配置的密码，用户名omnirpc改为你bitcoin.conf中配置的用户名： 1jian@ubuntu:~$ curl --user omnicorerpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnetworkinfo&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332 能返回下面的信息表示启动成功 1&#123;&quot;result&quot;:&#123;&quot;version&quot;:130200,&quot;subversion&quot;:&quot;/Satoshi:0.13.2/&quot;,&quot;protocolversion&quot;:70015,&quot;localservices&quot;:&quot;000000000000000d&quot;,&quot;localrelay&quot;:true,&quot;timeoffset&quot;:0,&quot;connections&quot;:2,&quot;networks&quot;:[&#123;&quot;name&quot;:&quot;ipv4&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;ipv6&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;onion&quot;,&quot;limited&quot;:true,&quot;reachable&quot;:false,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;],&quot;relayfee&quot;:0.00001000,&quot;localaddresses&quot;:[],&quot;warnings&quot;:&quot;&quot;&#125;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 停止omnicore程序1jian@ubuntu:~/.omni$ omnicore-cli -conf=/home/jian/.bitcoin/bitcoin.conf stop 检查区块同步信息检查同步日志（刷屏）： 12345678910111213jian@ubuntu:~$ cd ~/omnidata/testnet3/jian@ubuntu:~/omnidata/testnet3$ tail -f debug.log 2018-11-21T02:40:28Z net thread start2018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=12018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=02018-11-21T02:40:32Z 108 addresses found from DNS seeds2018-11-21T02:40:32Z dnsseed thread exit2018-11-21T02:40:36Z New outbound peer connected: version: 70015, blocks=1444366, peer=22018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=52018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=32018-11-21T02:40:41Z New outbound peer connected: version: 70015, blocks=1444366, peer=42018-11-21T02:40:48Z New outbound peer connected: version: 70015, blocks=1414448, peer=6....... 查询当前同步到的区块数： 1jian@ubuntu:~/omnidata/testnet3$ curl --user omnicorerpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getblockcount&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 由于usdt是基于BTC的，所有可以在比特币测试链上查询测试网络中的总区块：https://www.blocktrail.com/tBTC 需要注意的是只有区块同步到最新才可以查到钱包余额，要同步完区块，需要70G以上的硬盘空间。 创建钱包地址123jian@ubuntu:~$ curl --user omnirpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnewaddress&quot;, &quot;params&quot;: [&quot;test&quot;] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/&#123;&quot;result&quot;:&quot;n1Axxy3WGwFci1GJffwdY55dRem92GKXAm&quot;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 返回结果中的 “n1Axxy3WGwFci1GJffwdY55dRem92GKXAm” 即为新创建的USDT钱包，以m开头表示是测试链的钱包地址，公链上的钱包地址一般是1开头 查询余额查询比特币余额 1jian@ubuntu:~$ curl --user omnicorerpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getbalance&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 查询USDT余额，请将钱包地址换成你的 1jian@ubuntu:~$ omnicore-cli omni_getbalance &quot;n1Axxy3WGwFci1GJffwdY55dRem92GKXAm&quot; 1 或者 1jian@ubuntu:~$ curl --user omnicorerpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;omni_getbalance&quot;, &quot;params&quot;: [&quot;n1Axxy3WGwFci1GJffwdY55dRem92GKXAm&quot;, 1] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 获取测试币在下面两个网站中可以获得少量的测试比特币，用来做USDT交易手续费测试足够了，此时区块必须同步到最新，要不然获取不到余额： https://coinfaucet.eu/en/btc-testnet/ http://bitcoinfaucet.uo1.net/send.php 获取到比特币之后用下面的命令往moneyqMan7uh8FqdCA2BV5yZ8qVrc9ikLP发送比特币可以得到一点测试的USDT，每1BTC可以获得100个USDT，这里发送0.1个获得USDT10个 1jian@ubuntu:~$omnicore-cli -testnet sendtoaddress &quot;moneyqMan7uh8FqdCA2BV5yZ8qVrc9ikLP&quot; 0.1 你可以在比特币区块链浏览器查到btc余额：https://live.blockcypher.com/btc-testnet/address/2MtW8kA68TMrBLZb373WttjHbxfuRNdvHh7/ ，但是测试网络的usdt只能在你本地用命令行查，区块链浏览器查不到的。 发送交易参数分别是from，to，代币id，交易数量，支付btc手续费的地址 1jian@ubuntu:~$ omnicore-cli &quot;omni_funded_send&quot; &quot;n1Axxy3WGwFci1GJffwdY55dRem92GKXAm&quot; &quot;n4VTWrjPV1QaLmM1x8ZtyLiJoFk3KaCAsi&quot; 1 &quot;1&quot; &quot;n1Axxy3WGwFci1GJffwdY55dRem92GKXAm&quot; JSON-RPC可以查看：https://github.com/OmniLayer/omnicore/blob/master/src/omnicore/doc/rpc-api.md，需要用编程语言对接的话可以使用api中的函数和参数拼装成json数据，例如本文中的查询余额的 json 为{&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getbalance&quot;, &quot;params&quot;: [] }，然后将这串json作为参数post提交到节点的ip和端口即可返回相应的json结果。]]></content>
      <categories>
        <category>USDT</category>
      </categories>
      <tags>
        <tag>测试环境</tag>
        <tag>USDT</tag>
        <tag>Omni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu以太坊私有链搭建]]></title>
    <url>%2F2018%2F12%2F22%2F7.Ubuntu%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 安装geth123jian@ubuntu:~$ sudo add-apt-repository -y ppa:ethereum/ethereumjian@ubuntu:~$ sudo apt-get updatejian@ubuntu:~$ sudo apt-get install ethereum 查看geth版本 123456789101112jian@ubuntu:~$ geth versionWARN [12-20|00:00:20.173] Sanitizing cache to Go&apos;s GC limits provided=1024 updated=661GethVersion: 1.8.20-stableGit Commit: 24d727b6d6e2c0cde222fa12155c4a6db5caaf2eArchitecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.10.4Operating System: linuxGOPATH=GOROOT=/usr/lib/go-1.10 创世区块新建ethereum文件夹,然后在ethereum文件夹中创建data文件夹（存储区块数据）和genesis.json文件，打开genesis.json文件将创世区块代码复制到文件中并保存 1234jian@ubuntu:~$ mkdir ethereumjian@ubuntu:~$ cd ethereum/jian@ubuntu:~/ethereum$ mkdir datajian@ubuntu:~/ethereum$ vi genesis.json 创世区块数据 123456789101112&#123; &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x400&quot;, &quot;alloc&quot;: &#123;&#125;, &quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;, &quot;timestamp&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x&quot;, &quot;gasLimit&quot;: &quot;0x8000000&quot;, &quot;config&quot;: &#123;&#125;&#125; 参数说明 参数名 说明 nonce nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。 difficulty 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度 alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。 coinbase 矿工的账号,任意填写一个账号即可。 imestamp 设置创世块的时间戳 parentHash 上一个区块的hash值，因为是创世块，所以这个值是0 extraData 附加信息，随便填，可以填你的个性信息 gasLimit 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。 mixhash 与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。. 创建创世区块 123456789101112jian@ubuntu:~/ethereum$ geth --datadir data init genesis.jsonWARN [12-20|00:01:37.255] Sanitizing cache to Go&apos;s GC limits provided=1024 updated=661INFO [12-20|00:01:37.257] Maximum peer count ETH=25 LES=0 total=25INFO [12-20|00:01:37.276] Allocated cache and file handles database=/home/jian/ethereum/data/geth/chaindata cache=16 handles=16INFO [12-20|00:01:37.285] Writing custom genesis block INFO [12-20|00:01:37.286] Persisted trie from memory database nodes=0 size=0.00B time=2.214µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [12-20|00:01:37.287] Successfully wrote genesis state database=chaindata hash=6231b0…a0300bINFO [12-20|00:01:37.287] Allocated cache and file handles database=/home/jian/ethereum/data/geth/lightchaindata cache=16 handles=16INFO [12-20|00:01:37.292] Writing custom genesis block INFO [12-20|00:01:37.293] Persisted trie from memory database nodes=0 size=0.00B time=2.226µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [12-20|00:01:37.294] Successfully wrote genesis state database=lightchaindata hash=6231b0…a0300b 启动私有链1jian@ubuntu:~/ethereum$ geth --port 3000 --networkid 15 --datadir=&quot;data&quot; --maxpeers=3 --rpc --rpcport 8545 --rpcaddr 127.0.0.1 --rpccorsdomain &quot;*&quot; --rpcapi=&quot;db,eth,web3,personal,admin,txpool&quot; console 启动成功会进入js控制台 123456Welcome to the Geth JavaScript console!instance: Geth/v1.8.20-stable-24d727b6/linux-amd64/go1.10.4 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 退出私有链只需要输入exit即可，如果要让另外一台电脑访问私有链，需要将 –rpcaddr 设置为本机ip 创建钱包在js控制台输入命令 12&gt; personal.newAccount(&apos;123456&apos;)&quot;0xee340225c3b9348847c828881a34ae3237e91456&quot; 得到解锁密码为123456，钱包地址为”0xee340225c3b9348847c828881a34ae3237e91456”的以太坊钱包，第一个创建的钱包地址会自动作为默认钱包，挖矿得到的ETH会存入默认钱包中，查看默认钱包： 12&gt; eth.coinbase&quot;0xee340225c3b9348847c828881a34ae3237e91456&quot; 钱包列表列出所有钱包 12&gt; eth.accounts[&quot;0xee340225c3b9348847c828881a34ae3237e91456&quot;] 查询余额12&gt; eth.getBalance(&apos;0xee340225c3b9348847c828881a34ae3237e91456&apos;)0 或者根据钱包列表的序号 12&gt; eth.getBalance(eth.accounts[0])0 如果是默认钱包还可以这样 12&gt; eth.getBalance(eth.coinbase)0 开启挖矿挖矿会生成区块和执行交易，挖矿得到的ETH会存入默认钱包中，如果想修改默认钱包可以用以下命令 1&gt; miner.setEtherbase(&quot;0xa91Ae941e92eb6Fa78FE0d8215F01cbE6b7C014c&quot;) 开启挖矿，1表示1个线程 123456789&gt; miner.start(1)INFO [12-20|00:16:58.760] Generating DAG in progress epoch=0 percentage=0 elapsed=4.311sINFO [12-20|00:17:03.084] Generating DAG in progress epoch=0 percentage=1 elapsed=8.635sINFO [12-20|00:17:07.498] Generating DAG in progress epoch=0 percentage=2 elapsed=13.049sINFO [12-20|00:17:11.975] Generating DAG in progress epoch=0 percentage=3 elapsed=17.526sINFO [12-20|00:17:16.302] Generating DAG in progress epoch=0 percentage=4 elapsed=21.853sINFO [12-20|00:17:20.855] Generating DAG in progress epoch=0 percentage=5 ...... 第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，大概需要10分钟，等到 percentage = 100后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。看到类似下面的信息表示挖矿成功 123456789INFO [12-20|00:42:41.957] 🔗 block reached canonical chain number=2 hash=9a053e…3b1a92INFO [12-20|00:42:41.957] 🔨 mined potential block number=9 hash=3067bd…6eb8e3INFO [12-20|00:42:41.978] Commit new mining work number=10 sealhash=3958ea…fc97b1 uncles=0 txs=0 gas=0 fees=0 elapsed=103.483µsINFO [12-20|00:42:47.737] Generating DAG in progress epoch=1 percentage=31 elapsed=17m30.277sINFO [12-20|00:42:53.206] Successfully sealed new block number=10 sealhash=3958ea…fc97b1 hash=ae06e1…929511 elapsed=11.228sINFO [12-20|00:42:53.207] 🔗 block reached canonical chain number=3 hash=c5335d…b00c0cINFO [12-20|00:42:53.207] 🔨 mined potential block number=10 hash=ae06e1…929511INFO [12-20|00:42:53.223] Commit new mining work number=11 sealhash=512ca2…b5efb9 uncles=0 txs=0 gas=0 fees=0 elapsed=92.66µs...... 此时新打开终端，用 geth attach 命令连接到js控制台再查询默认钱包余额,发现已经有币了 1234jian@ubuntu:~$ cd ~/ethereum/datajian@ubuntu:~/ethereum/data$ geth attach ipc:geth.ipc&gt; eth.getBalance(eth.coinbase)175000000000000000000 余额的单位是GWEI,要转为ETH只要除以10的18次方即可，这里的余额为175ETH 停止挖矿1&gt; miner.stop() 区块高度区块高度也叫区块数量、最新区块 12&gt; eth.blockNumber186 解锁钱包以太坊钱包大概每5分钟就会被锁住，交易和创建合约都需要先解锁,输入下面的命令和钱包密码即可解锁 1234&gt; personal.unlockAccount(&quot;0xee340225c3b9348847c828881a34ae3237e91456&quot;) Unlock account 0xee340225c3b9348847c828881a34ae3237e91456Passphrase: true 发送交易发送交易前请先解锁转出地钱包并启动挖矿，然后使用eth.sendTransaction命令发送交易，下面的命令将从eth.accounts[0]转5个ETH到eth.accounts[1]，也可以替换成具体的钱包地址： 123456&gt; amount = web3.toWei(5,&apos;ether&apos;) &quot;5000000000000000000&quot; &gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;) I0322 19:39:36.300675 internal/ethapi/api.go:1047] Tx(0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825) to: 0x814d39aa21f3eed069f2b21da7b5f857f7343afa &quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot; 发送成功将返回交易哈希，等待挖矿执行交易，再查看余额可以看到已经到账 12&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;) 5 查询交易可以根据交易哈希查询该交易的详细信息 1234567891011121314151617&gt; eth.getTransaction(&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;) &#123; blockHash: &quot;0xf5d3da50065ce5793c9571a031ad6fe5f1af326a3c4fb7ce16458f4d909c1613&quot;, blockNumber: 33, from: &quot;0xc232e2add308136571bb8f9197ba4ae4e5ba9836&quot;, gas: 90000, gasPrice: 20000000000, hash: &quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;, input: &quot;0x&quot;, nonce: 0, r: &quot;0x433fe5845391b6da3d8aa0d2b53674e09fb6126f0070a600686809b57e4ef77d&quot;, s: &quot;0x6b0086fb76c46024f849141074a5bc79c49d5f9a658fd0fedbbe354889c34d8d&quot;, to: &quot;0x814d39aa21f3eed069f2b21da7b5f857f7343afa&quot;, transactionIndex: 0, v: &quot;0x1b&quot;, value: 5000000000000000000 &#125; 连接节点如果局域网内有多个私有链节点，可以将这些节点连接起来组成链，这些节点会同步相同的区块和交易，相当于小型的公链。但是要将这些节点连接起来需要满足3个条件： 节点所在的机器，相互之间可以互联互通网络 有相同的创世区块 在启动私有链的geth命令中设置相同的networkid 假设有两个节点：节点一（ubuntu端）和节点二（windows端），它们的geth启动命令中的networkid都是1108，首先要知道节点二的enode信息，启动节点二的私有链，在js console中执行下面的命令查看enode信息： 12&gt; admin.nodeInfo.enode &quot;enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@[::]:30304&quot; 复制上面给出的信息添加到admin.Peer的参数中，注意要把enode中的[::]替换成节点二的IP地址。然后在节点一的js console中执行admin.addPeer()，就可以连接到节点二了 1&gt; admin.addPeer(&quot;enode://9e86289ea859ca041f235aed87a091d0cd594b377cbe13e1c5f5a08a8a280e62d4019ac54063ed6a1d0e3c3eaedad0b73c40b99a16a176993f0373ffe92be672@192.168.1.111:30304&quot;) 连接成功后，节点一和节点二就会开始同步的区块，保证区块数据一致。使用admin.peers命令可以查看当前网络连接在一起的所有节点 1234567891011121314151617181920212223242526272829303132333435363738&gt; admin.peers[&#123; caps: [&quot;eth/62&quot;, &quot;eth/63&quot;], id: &quot;070b16d058df62a934bb1b9f6e216f6763d63c51011c559d0ad155ae428294c69aed1e35a46c36a6613989941b67b530ab92c7667bd63e7e8a7a5717a266751f&quot;, name: &quot;Geth/v1.8.12-stable/linux-amd64/go1.9.2&quot;, network: &#123; inbound: true, localAddress: &quot;172.31.238.175:30303&quot;, remoteAddress: &quot;145.239.0.91:51238&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &#123; difficulty: 8.379127609415399e+21, head: &quot;0x7ce58e50b8bc9af80c6900729801832ec9a5f86e549930e085f1a208dacf5608&quot;, version: 63 &#125; &#125;&#125;, &#123; caps: [&quot;eth/62&quot;, &quot;eth/63&quot;], id: &quot;19211a5d0fbcabf5184e49639839bda772080cba500a4a0e9ced1f89c3a43fea1c00d4d8de5a463d6002bfa594e46e2c03611a6514117f1bd8c7e889bfb4ec7a&quot;, name: &quot;Geth/v1.8.18-unstable-126dfde6/linux-amd64/go1.9.4&quot;, network: &#123; inbound: true, localAddress: &quot;172.31.238.175:30303&quot;, remoteAddress: &quot;120.78.87.202:53548&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &#123; difficulty: 5.481064970682881e+21, head: &quot;0xdb982b1ff69083b090549c3809dd6b58f87ca50db97e0b4144aac9269ad198be&quot;, version: 63 &#125; &#125;&#125;] 参考文章[1] https://my.oschina.net/u/2349981/blog/856956 [2] http://blog.csdn.net/u013096666/article/details/72639906 [3] http://qiita.com/oggata/items/eea4d5e37f38785f6079]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>ethereum</tag>
        <tag>私有链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOS调用Json-RPC接口]]></title>
    <url>%2F2018%2F12%2F07%2F16.EOS%E8%B0%83%E7%94%A8Json-RPC%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian联系方式：jian1098@qq.com 接口说明本文基于EOS私有链环境，理论上测试环境也可以，比如jungle测试链，但是测试链提供的节点服务器一般无法使用wallet相关的接口，比如创建钱包、交易签名等，因为没有开启–filter-on。私有链的搭建步骤可以参见我的另一篇文章《Ubuntu下EOS测试环境(私链)搭建》。 本文的所有参数都是json格式，以表单字段格式post是不行的。 旧版本的eos的chain和wallet功能都是有nodeos程序执行的，新版本更新后与wallet相关的RPC接口改为keosd程序控制，所以要使用与wallet相关的RPC接口必须先启动keosd程序，并且两个程序的端口不能相同。本文的nodeos程序端口为默认的8888，keosd程序端口设置为8889。 nodeos程序是可以不运行在本地的，运行在本地的是私有链，也可以本地不运行，直接连接主网或者测试网络的ip和端口。但是keosd是要运行在本地的，主网和测试网络上没有提供对钱包操作相关的接口，只能在本地操作钱包。所以如果要创建一个EOS节点，要操作钱包的话，不管是私链，主网还是测试网，都要一台服务器编译源码，然后启动keosd来管理钱包账号。 启动nodeos12jian@ubuntu:~$ cd ~/eos/build/programs/nodeosjian@ubuntu:~$ sudo ./nodeos -e -p eosio -d /data/eos --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin --plugin eosio::bnet_plugin --contracts-console --filter-on &quot;*&quot; --access-control-allow-origin &quot;*&quot; --max-transaction-time=1000 --verbose-http-errors 启动成功后大约每0.5秒就产生一个区块 启动keosd打开另一个终端执行，ip地址192.168.1.131:8889改为你的本地ip 12jian@ubuntu:~$ cd ~/eos/build/programs/keosdjian@ubuntu:~/eos/build/programs/keosd$ ./keosd --http-server-address 192.168.1.115:8889 --access-control-allow-origin &quot;*&quot; --plugin eosio::wallet_api_plugin --verbose-http-errors --plugin eosio::wallet_plugin 这里会出现一个错误警告，但是不影响后面的操作 12345678910error 2018-12-08T02:48:31.877 thread-0 wallet_api_plugin.cpp:123 plugin_initialize ] ********!!!SECURITY ERROR!!!********* ** -- Wallet API -- ** - EXPOSED to the LOCAL NETWORK - ** - HTTP RPC is NOT encrypted - ** - Password and/or Private Keys - ** - are at HIGH risk of exposure - ** ************************************* 访问RPC接口在浏览器打开：http://127.0.0.1:8888/v1/chain/get_info ，推荐使用postman等http调试工具进行调试，云服务器请在安全组策略开放8888和8889两个端口。 如果需要开放给外部浏览器访问RPC端口，需要修改配置文件： 12jian@ubuntu:~/eos$ cd ~/.local/share/eosio/nodeos/configjian@ubuntu:~/.local/share/eosio/nodeos/config$ sudo vi config.ini 将 http-server-address = 127.0.0.1:8888改为你的公网ip和端口即可，或者在启动命令添加参数 –http-server-address = 192.168.1.123:8888，然后在浏览器打开：http://192.168.1.123:8888/v1/chain/get_info 。修改后在命令行对使用cleos程序都必须带上 –url http://192.168.1.131:8888，例如： 1sudo ./cleos --url http://192.168.1.131:8888 get account ubuntueos111 chain相关接口获取节点信息接口链接：http://192.168.1.131:8888/v1/chain/get_info psot参数：无 返回数据： 123456789101112131415&#123; &quot;server_version&quot;: &quot;549c96cd&quot;, &quot;chain_id&quot;: &quot;e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473&quot;, &quot;head_block_num&quot;: 2334727, &quot;last_irreversible_block_num&quot;: 2334397, &quot;last_irreversible_block_id&quot;: &quot;00239ebdb4ef886adebd4eb456326acb833325ac05f0c2b94aca523272ac5ca0&quot;, &quot;head_block_id&quot;: &quot;0023a0070c2267d1bff305c62d0285d0ccf6ab021b3a624f1daab70866dae6e5&quot;, &quot;head_block_time&quot;: &quot;2018-12-07T09:09:50.500&quot;, &quot;head_block_producer&quot;: &quot;batinthedark&quot;, &quot;virtual_block_cpu_limit&quot;: 200000000, &quot;virtual_block_net_limit&quot;: 1048576000, &quot;block_cpu_limit&quot;: 199920, &quot;block_net_limit&quot;: 1048576, &quot;server_version_string&quot;: &quot;v1.5.0-rc2&quot;&#125; 获取区块信息接口链接：http://192.168.1.131:8888/v1/chain/get_block psot参数：{“block_num_or_id”:”13598552”} 返回数据： 1234567891011121314151617&#123; &quot;code&quot;: 500, &quot;message&quot;: &quot;Internal Service Error&quot;, &quot;error&quot;: &#123; &quot;code&quot;: 3010008, &quot;name&quot;: &quot;block_id_type_exception&quot;, &quot;what&quot;: &quot;Invalid block ID&quot;, &quot;details&quot;: [ &#123; &quot;message&quot;: &quot;Invalid Block number or ID, must be greater than 0 and less than 64 characters&quot;, &quot;file&quot;: &quot;chain_plugin.cpp&quot;, &quot;line_number&quot;: 1484, &quot;method&quot;: &quot;get_block&quot; &#125; ] &#125;&#125; 获取账户信息接口链接：http://192.168.1.131:8888/v1/chain/get_account psot参数：{“account_name”:”account1”} 返回数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; &quot;account_name&quot;: &quot;exchange1234&quot;, &quot;head_block_num&quot;: 2337585, &quot;head_block_time&quot;: &quot;2018-12-07T09:33:49.500&quot;, &quot;privileged&quot;: false, &quot;last_code_update&quot;: &quot;1970-01-01T00:00:00.000&quot;, &quot;created&quot;: &quot;2018-11-29T06:01:52.000&quot;, &quot;core_liquid_balance&quot;: &quot;200.0000 EOS&quot;, &quot;ram_quota&quot;: 5467, &quot;net_weight&quot;: 10000, &quot;cpu_weight&quot;: 10000, &quot;net_limit&quot;: &#123; &quot;used&quot;: 0, &quot;available&quot;: 273176, &quot;max&quot;: 273176 &#125;, &quot;cpu_limit&quot;: &#123; &quot;used&quot;: 0, &quot;available&quot;: 51893, &quot;max&quot;: 51893 &#125;, &quot;ram_usage&quot;: 3446, &quot;permissions&quot;: [ &#123; &quot;perm_name&quot;: &quot;active&quot;, &quot;parent&quot;: &quot;owner&quot;, &quot;required_auth&quot;: &#123; &quot;threshold&quot;: 1, &quot;keys&quot;: [ &#123; &quot;key&quot;: &quot;EOS6PDC4Cn87RPPKgyrT3faf3pMrAuppLHqpJaxHRuZgkCTqzUduS&quot;, &quot;weight&quot;: 1 &#125; ], &quot;accounts&quot;: [], &quot;waits&quot;: [] &#125; &#125;, &#123; &quot;perm_name&quot;: &quot;owner&quot;, &quot;parent&quot;: &quot;&quot;, &quot;required_auth&quot;: &#123; &quot;threshold&quot;: 1, &quot;keys&quot;: [ &#123; &quot;key&quot;: &quot;EOS6PDC4Cn87RPPKgyrT3faf3pMrAuppLHqpJaxHRuZgkCTqzUduS&quot;, &quot;weight&quot;: 1 &#125; ], &quot;accounts&quot;: [], &quot;waits&quot;: [] &#125; &#125; ], &quot;total_resources&quot;: &#123; &quot;owner&quot;: &quot;exchange1234&quot;, &quot;net_weight&quot;: &quot;1.0000 EOS&quot;, &quot;cpu_weight&quot;: &quot;1.0000 EOS&quot;, &quot;ram_bytes&quot;: 4067 &#125;, &quot;self_delegated_bandwidth&quot;: &#123; &quot;from&quot;: &quot;exchange1234&quot;, &quot;to&quot;: &quot;exchange1234&quot;, &quot;net_weight&quot;: &quot;1.0000 EOS&quot;, &quot;cpu_weight&quot;: &quot;1.0000 EOS&quot; &#125;, &quot;refund_request&quot;: null, &quot;voter_info&quot;: &#123; &quot;owner&quot;: &quot;exchange1234&quot;, &quot;proxy&quot;: &quot;&quot;, &quot;producers&quot;: [], &quot;staked&quot;: 20000, &quot;last_vote_weight&quot;: &quot;0.00000000000000000&quot;, &quot;proxied_vote_weight&quot;: &quot;0.00000000000000000&quot;, &quot;is_proxy&quot;: 0, &quot;reserved1&quot;: 0, &quot;reserved2&quot;: 0, &quot;reserved3&quot;: &quot;0 &quot; &#125;&#125; 获取指定币种信息接口链接：http://192.168.1.131:8888/v1/chain/get_currency_stats psot参数：{“code”:”eosio.token”, “symbol”:”EOS”} 返回数据： 1234567&#123; &quot;EOS&quot;: &#123; &quot;supply&quot;: &quot;8014684620.4023 EOS&quot;, &quot;max_supply&quot;: &quot;100000000000.0000 EOS&quot;, &quot;issuer&quot;: &quot;eosio&quot; &#125;&#125; json 转 bin接口链接：http://192.168.1.131:8888/v1/chain/abi_json_to_bin psot参数： 12345678910&#123; &quot;code&quot;: &quot;eosio.token&quot;, &quot;action&quot;: &quot;transfer&quot;, &quot;args&quot;: &#123; &quot;from&quot;: &quot;eosio&quot;, &quot;to&quot;: &quot;exchange1111&quot;, &quot;quantity&quot;: &quot;100.0000 EOS&quot;, &quot;memo&quot;: &quot;send&quot; &#125;&#125; 返回数据： 123&#123; &quot;binargs&quot;: &quot;0086088a4dd350571042088a4dd3505740420f000000000004454f53000000000473656e64&quot;&#125; 查询余额接口链接：http://192.168.1.131:8888/v1/chain/get_currency_balance psot参数： {“code”:”eosio.token”, “account”: “account1”, “symbol”:”EOS”} 参数说明：account为账号名，symbol为指定代币名 返回数据： 123[ &quot;200.0000 EOS&quot;] wallet相关接口 注意与wallet相关的接口需要启动keosd程序，并且端口为8889 创建钱包接口链接：http://192.168.1.131:8889/v1/wallet/create psot参数：”account1” 参数说明：传入需要创建的账号名即可,返回结果是钱包的私钥 返回数据： 1&quot;PW5HrziwLJZYntiyNQnS7F9FSFFJAGjeZSDT2U5tbR5WVxWVgapRv&quot; 钱包列表接口链接：http://192.168.1.131:8889/v1/wallet/list_wallets psot参数：无 返回数据： 12345[ &quot;account1&quot;, &quot;account2&quot;, &quot;account3 *&quot;] 锁定指定钱包接口链接：http://192.168.1.131:8889/v1/wallet/lock psot参数：”accountname” 参数说明：传入需要解锁的账号名即可 返回数据： 1&#123;&#125; 锁定所有钱包接口链接：http://192.168.1.131:8889/v1/wallet/lock_all psot参数：无 返回数据： 1&#123;&#125; 解锁钱包接口链接：http://192.168.1.131:8889/v1/wallet/unlock psot参数：[“account3”, “PW5Kxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”] 参数说明：传入需要解锁的账号名和私钥 返回数据： 1&#123;&#125; 设置自动锁定时间接口链接：http://192.168.1.131:8889/v1/wallet/set_timeout psot参数：3600 参数说明：单位是秒 返回数据： 1&#123;&#125; 获取所有钱包中的公钥接口链接：http://192.168.1.131:8889/v1/wallet/get_public_keys psot参数：无 返回数据： 123[ &quot;EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt&quot;] 导入私钥接口链接：http://192.168.1.131:8889/v1/wallet/import_key psot参数：[“account3”,”5JxhYZZnFJJMRrf7KkSHNLFq2LM4eZigJfeKXXYSa1TvPMdWtLc”] 参数说明：账号名和密钥对的私钥 返回数据： 1&#123;&#125; 获取指定钱包的公私钥对接口链接：http://192.168.1.131:8889/v1/wallet/list_keys psot参数：[“account3”,”PW5HrziwLJZYntiyNQnS7F9FSFFJAGjeZSDT2U5tbR5WVxWVgapRv”] 参数说明：账号名和私钥，返回私钥对的public key和private key 返回数据： 123456[ [ &quot;EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt&quot;, &quot;5JxhYZZnFJJMRrf7KkSHNLFq2LM4eZigJfeKXXYSa1TvPMdWtLc&quot; ]] history相关接口要使用history相关的接口，节点启动必须--filter-on &quot;*&quot;参数，一般网上公开的节点是不开启的，所以查到的数据为空 获取指定账号的交易记录接口链接：http://192.168.1.115:8888/v1/history/get_actions psot参数：{“pos”:0,”offset”:5,”account_name”:”exchange2222”} 参数说明：偏移量、查找数量和要查询的账号名，前两个参数好像不起作用。 如果是在jungle测试网络，可以逐个节点测试，一般都会有几个节点打开--filter-on的，例如 http://jungle2-eos.blckchnd.com:8888 这个节点 返回数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&#123; &quot;actions&quot;: [ &#123; &quot;global_action_seq&quot;: 19298, &quot;account_action_seq&quot;: 0, &quot;block_num&quot;: 19240, &quot;block_time&quot;: &quot;2018-07-22T02:55:42.000&quot;, &quot;action_trace&quot;: &#123; &quot;receipt&quot;: &#123; &quot;receiver&quot;: &quot;exchange2222&quot;, &quot;act_digest&quot;: &quot;f8ce7062290be813e6484e50c7c0e3c22a9898e3240bab76f7e11b99c07abe52&quot;, &quot;global_sequence&quot;: 19298, &quot;recv_sequence&quot;: 5, &quot;auth_sequence&quot;: [ [ &quot;eosio&quot;, ] ], &quot;code_sequence&quot;: 1, &quot;abi_sequence&quot;: 1 &#125;, &quot;act&quot;: &#123; &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;transfer&quot;, &quot;authorization&quot;: [ &#123; &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; &#125; ], &quot;data&quot;: &#123; &quot;from&quot;: &quot;eosio&quot;, &quot;to&quot;: &quot;exchange2222&quot;, &quot;quantity&quot;: &quot;10.0000 SYS&quot;, &quot;memo&quot;: &quot;&quot; &#125;, &quot;hex_data&quot;: &quot;0000000000ea305500dca79ab1e98e49a086010000000000045359530000000000&quot; &#125;, &quot;elapsed&quot;: 6, &quot;cpu_usage&quot;: 0, &quot;console&quot;: &quot;&quot;, &quot;total_cpu_usage&quot;: 0, &quot;trx_id&quot;: &quot;b09395d938e594b838277453cea832ddc5d57ab5e92d8763ea011df9e35d7b34&quot;, &quot;inline_traces&quot;: [] &#125; &#125;, &#123; &quot;global_action_seq&quot;: 21095, &quot;account_action_seq&quot;: 1, &quot;block_num&quot;: 21034, &quot;block_time&quot;: &quot;2018-07-22T03:10:39.000&quot;, &quot;action_trace&quot;: &#123; &quot;receipt&quot;: &#123; &quot;receiver&quot;: &quot;exchange2222&quot;, &quot;act_digest&quot;: &quot;72ae6a2af84b85d4b4e20190a56904f53afa2a79ab4c47ca2f15874c4c309205&quot;, &quot;global_sequence&quot;: 21095, &quot;recv_sequence&quot;: 6, &quot;auth_sequence&quot;: [ [ &quot;eosio&quot;, ] ], &quot;code_sequence&quot;: 1, &quot;abi_sequence&quot;: 1 &#125;, &quot;act&quot;: &#123; &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;transfer&quot;, &quot;authorization&quot;: [ &#123; &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; &#125; ], &quot;data&quot;: &#123; &quot;from&quot;: &quot;eosio&quot;, &quot;to&quot;: &quot;exchange2222&quot;, &quot;quantity&quot;: &quot;2.0000 SYS&quot;, &quot;memo&quot;: &quot;&quot; &#125;, &quot;hex_data&quot;: &quot;0000000000ea305500dca79ab1e98e49204e000000000000045359530000000000&quot; &#125;, &quot;elapsed&quot;: 6, &quot;cpu_usage&quot;: 0, &quot;console&quot;: &quot;&quot;, &quot;total_cpu_usage&quot;: 0, &quot;trx_id&quot;: &quot;e1cafa2561470a0b489a4e2032375a5c88665f75e5172bac7b574cd051079d42&quot;, &quot;inline_traces&quot;: [] &#125; &#125; ], &quot;last_irreversible_block&quot;: 64270&#125; 根据交易id查询交易信息接口链接：http://192.168.1.115:8888/v1/history/get_transaction psot参数：{“id”:”50c9bedc542a5d17a66bace81486d2fc2e3b047ed67d34c2ad0c1c6d75040948”} 返回数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; &quot;id&quot;: &quot;50c9bedc542a5d17a66bace81486d2fc2e3b047ed67d34c2ad0c1c6d75040948&quot;, &quot;trx&quot;: &#123; &quot;receipt&quot;: &#123; &quot;status&quot;: &quot;executed&quot;, &quot;cpu_usage_us&quot;: 4933, &quot;net_usage_words&quot;: 17, &quot;trx&quot;: [ 1, &#123; &quot;signatures&quot;: [ &quot;SIG_K1_KiSVEWDyt5DcxB4wyKGBg1DQGMbxNqPBr7ac3ia7qgU3wopTmnvePWisi8ZvaxVerciCVrZaRaQxcYmjqzvXCZVbx4f66T&quot; ], &quot;compression&quot;: &quot;none&quot;, &quot;packed_context_free_data&quot;: &quot;&quot;, &quot;packed_trx&quot;: &quot;08600b5c7c634a617031000000000100a6823403ea3055000000572d3ccdcd010000000000ea305500000000a8ed3232250000000000ea3055000000214f4d113240420f000000000004454f5300000000046d656d6f00&quot; &#125; ] &#125;, &quot;trx&quot;: &#123; &quot;expiration&quot;: &quot;2018-12-08T06:09:12&quot;, &quot;ref_block_num&quot;: 25468, &quot;ref_block_prefix&quot;: 829448522, &quot;max_net_usage_words&quot;: 0, &quot;max_cpu_usage_ms&quot;: 0, &quot;delay_sec&quot;: 0, &quot;context_free_actions&quot;: [], &quot;actions&quot;: [ &#123; &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;transfer&quot;, &quot;authorization&quot;: [ &#123; &quot;actor&quot;: &quot;eosio&quot;, &quot;permission&quot;: &quot;active&quot; &#125; ], &quot;data&quot;: &#123; &quot;from&quot;: &quot;eosio&quot;, &quot;to&quot;: &quot;account1&quot;, &quot;quantity&quot;: &quot;100.0000 EOS&quot;, &quot;memo&quot;: &quot;memo&quot; &#125;, &quot;hex_data&quot;: &quot;0000000000ea3055000000214f4d113240420f000000000004454f5300000000046d656d6f&quot; &#125; ], &quot;transaction_extensions&quot;: [], &quot;signatures&quot;: [ &quot;SIG_K1_KiSVEWDyt5DcxB4wyKGBg1DQGMbxNqPBr7ac3ia7qgU3wopTmnvePWisi8ZvaxVerciCVrZaRaQxcYmjqzvXCZVbx4f66T&quot; ], &quot;context_free_data&quot;: [] &#125; &#125;, ............. &#125; ]&#125; 查询相同公钥的账号接口链接：http://192.168.1.131:8888/v1/history/get_key_accounts psot参数：{“public_key”:”EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt”} 参数说明：公钥 返回数据： 12345&#123; &quot;account_names&quot;: [ &quot;account1&quot; ]&#125; 交易相关接口通过RPC发送交易需要下面几个步骤 1.序列化交易信息接口链接：http://192.168.1.131:8888/v1/chain/abi_json_to_bin psot参数： 12345678910&#123; &quot;code&quot;: &quot;eosio.token&quot;, &quot;action&quot;: &quot;transfer&quot;, &quot;args&quot;: &#123; &quot;from&quot;: &quot;account1&quot;, &quot;to&quot;: &quot;account2&quot;, &quot;quantity&quot;: &quot;2.0000 EOS&quot;, &quot;memo&quot;: &quot;send to account2&quot; &#125;&#125; 参数说明：设置好from,to账号和数量，memo是备注 返回数据： 123&#123; &quot;binargs&quot;: &quot;000000214f4d1132000000224f4d1132204e00000000000004454f53000000001073656e6420746f206163636f756e7432&quot;&#125; 2.获取最新区块接口链接：http://192.168.1.131:8888/v1/chain/get_info psot参数：无 返回数据： 123456789101112131415&#123; &quot;server_version&quot;: &quot;ea08cfd3&quot;, &quot;chain_id&quot;: &quot;cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f&quot;, &quot;head_block_num&quot;: 43593, &quot;last_irreversible_block_num&quot;: 43592, &quot;last_irreversible_block_id&quot;: &quot;0000aa48c52fe5f17caf8adaca191a48c567bdb746feac4a92f65d3e7ced13ae&quot;, &quot;head_block_id&quot;: &quot;0000aa49cc362b1a6eba086a329b14e1c1933c0629a3e72b06b16b7862b8c18a&quot;, &quot;head_block_time&quot;: &quot;2018-12-08T08:42:33.500&quot;, &quot;head_block_producer&quot;: &quot;eosio&quot;, &quot;virtual_block_cpu_limit&quot;: 200000000, &quot;virtual_block_net_limit&quot;: 1048576000, &quot;block_cpu_limit&quot;: 199900, &quot;block_net_limit&quot;: 1048576, &quot;server_version_string&quot;: &quot;v1.5.0-dirty&quot;&#125; 得到最新区块为43593 3. 获取区块id接口链接：http://192.168.1.131:8888/v1/chain/get_block psot参数：{“block_num_or_id”:”43593”} 返回数据： 1234567891011121314151617&#123; &quot;timestamp&quot;: &quot;2018-12-08T08:42:33.500&quot;, &quot;producer&quot;: &quot;eosio&quot;, &quot;confirmed&quot;: 0, &quot;previous&quot;: &quot;0000aa48c52fe5f17caf8adaca191a48c567bdb746feac4a92f65d3e7ced13ae&quot;, &quot;transaction_mroot&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;action_mroot&quot;: &quot;7d8b4c41547eedad2be4418c53160051976acd272bce9d8688064bd846319772&quot;, &quot;schedule_version&quot;: 0, &quot;new_producers&quot;: null, &quot;header_extensions&quot;: [], &quot;producer_signature&quot;: &quot;SIG_K1_KctYCoHaaRHnVhyWj3AohoLwHzq8GbLShtT3H5yJ7uMG7GQujzfBmZ9JgNgv9JAxP6C6sgWXp89Fkvkdmbsx7zRLMJbfGF&quot;, &quot;transactions&quot;: [], &quot;block_extensions&quot;: [], &quot;id&quot;: &quot;0000aa49cc362b1a6eba086a329b14e1c1933c0629a3e72b06b16b7862b8c18a&quot;, &quot;block_num&quot;: 43593, &quot;ref_block_prefix&quot;: 1778956910&#125; 得到id和ref_block_prefix 4.获取from账号信息接口链接：http://192.168.1.131:8888/v1/chain/get_account psot参数：{“account_name”:”account1”} 返回数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; &quot;account_name&quot;: &quot;account1&quot;, &quot;head_block_num&quot;: 44703, &quot;head_block_time&quot;: &quot;2018-12-08T08:51:48.500&quot;, &quot;privileged&quot;: false, &quot;last_code_update&quot;: &quot;1970-01-01T00:00:00.000&quot;, &quot;created&quot;: &quot;2018-12-08T06:01:14.000&quot;, &quot;ram_quota&quot;: -1, &quot;net_weight&quot;: -1, &quot;cpu_weight&quot;: -1, &quot;net_limit&quot;: &#123; &quot;used&quot;: -1, &quot;available&quot;: -1, &quot;max&quot;: -1 &#125;, &quot;cpu_limit&quot;: &#123; &quot;used&quot;: -1, &quot;available&quot;: -1, &quot;max&quot;: -1 &#125;, &quot;ram_usage&quot;: 2724, &quot;permissions&quot;: [ &#123; &quot;perm_name&quot;: &quot;active&quot;, &quot;parent&quot;: &quot;owner&quot;, &quot;required_auth&quot;: &#123; &quot;threshold&quot;: 1, &quot;keys&quot;: [ &#123; &quot;key&quot;: &quot;EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa&quot;, &quot;weight&quot;: 1 &#125; ], &quot;accounts&quot;: [], &quot;waits&quot;: [] &#125; &#125;, &#123; &quot;perm_name&quot;: &quot;owner&quot;, &quot;parent&quot;: &quot;&quot;, &quot;required_auth&quot;: &#123; &quot;threshold&quot;: 1, &quot;keys&quot;: [ &#123; &quot;key&quot;: &quot;EOS5Fwtc4vnQE8AigimXvHrERrK7XFpycQ8Dijq2611timbVTReDt&quot;, &quot;weight&quot;: 1 &#125; ], &quot;accounts&quot;: [], &quot;waits&quot;: [] &#125; &#125; ], &quot;total_resources&quot;: null, &quot;self_delegated_bandwidth&quot;: null, &quot;refund_request&quot;: null, &quot;voter_info&quot;: null&#125; 可以得到active权限的公钥是EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa 5.解锁from钱包接口链接：http://192.168.1.131:8889/v1/wallet/unlock psot参数：[“account3”, “PW5Kxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”] 参数说明：传入需要解锁的账号名和私钥 返回数据： 1&#123;&#125; 6.交易签名1234567891011121314151617[&#123; &quot;ref_block_num&quot;: 43593, &quot;ref_block_prefix&quot;: 1778956910, &quot;expiration&quot;: &quot;2018-12-8T06:30:10.000&quot;, &quot;actions&quot;: [&#123; &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;transfer&quot;, &quot;authorization&quot;: [&#123; &quot;actor&quot;: &quot;account1&quot;, &quot;permission&quot;: &quot;active&quot; &#125;], &quot;data&quot;: &quot;000000214f4d1132000000224f4d1132204e00000000000004454f53000000001073656e6420746f206163636f756e7432&quot; &#125;], &quot;signatures&quot;: [] &#125;, [&quot;EOS75hPAeMGgAw9FYLTAHqjHyicjW82bB1q9grXqDtCdMDMpe1eoa&quot;], &quot;0000aa49cc362b1a6eba086a329b14e1c1933c0629a3e72b06b16b7862b8c18a&quot;] 参考文章https://www.jianshu.com/p/3c9cb9bc6fd6 https://eos.readthedocs.io/zh_CN/latest/API/EOSIO-RPC/]]></content>
      <categories>
        <category>EOS</category>
      </categories>
      <tags>
        <tag>EOS</tag>
        <tag>Json-RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu莱特币测试环境搭建]]></title>
    <url>%2F2018%2F11%2F22%2F13.Ubuntu%E8%8E%B1%E7%89%B9%E5%B8%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 安装litecoin核心123root@ubuntu:~# wget https://download.litecoin.org/litecoin-0.16.3/linux/litecoin-0.16.3-x86_64-linux-gnu.tar.gzroot@ubuntu:~# tar -zvxf litecoin-0.16.3-x86_64-linux-gnu.tar.gz root@ubuntu:~# install -m 0755 -o root -g root -t /usr/local/bin ./litecoin-0.16.3/bin/* 配置litecoin参数123root@ubuntu:~$ mkdir .litecoin #创建目录root@ubuntu:~$ cd .litecoin/root@ubuntu:~$ vi litecoin.conf 将下面信息全部复制，并修改rpcuser（RPC用户名），rpcpassword（RPC用户密码），rpcallowip（允许访问的ip地址）然后保存 1234567891011121314151617181920212223242526# Generated by https://jlopp.github.io/litecoin-core-config-generator/# This config should be placed in following path:# ~/.litecoin/litecoin.conf# [rpc]# Accept command line and JSON-RPC commands.server=1# Username for JSON-RPC connectionsrpcuser=litecoinrpc# Password for JSON-RPC connectionsrpcpassword=litecoinrpc# Listen for JSON-RPC connections on this portrpcport=18332# Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), # a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option # can be specified multiple times.rpcallowip=192.168.1.178rpcallowip=192.168.1.179# Run this node on the litecoin Test Network.testnet=1 启动litecoin程序12root@ubuntu:~/.litecoin$ litecoind -daemonLitecoin server starting 查看是否启动成功，需要输入上一步配置的密码，用户名litecoinrpc改为你配置的用户名： 12root@ubuntu:~$ curl --user litecoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnetworkinfo&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/Enter host password for user &apos;litecoinrpc&apos;: 能返回下面的信息表示启动成功 1&#123;&quot;result&quot;:&#123;&quot;version&quot;:170000,&quot;subversion&quot;:&quot;/Satoshi:0.17.0/&quot;,&quot;protocolversion&quot;:70015,&quot;localservices&quot;:&quot;000000000000040d&quot;,&quot;localrelay&quot;:true,&quot;timeoffset&quot;:0,&quot;networkactive&quot;:true,&quot;connections&quot;:5,&quot;networks&quot;:[&#123;&quot;name&quot;:&quot;ipv4&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;ipv6&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;onion&quot;,&quot;limited&quot;:true,&quot;reachable&quot;:false,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;],&quot;relayfee&quot;:0.00001000,&quot;incrementalfee&quot;:0.00001000,&quot;localaddresses&quot;:[],&quot;warnings&quot;:&quot;&quot;&#125;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 停止litecoin程序12root@ubuntu:~/.litecoin/testnet3$ litecoin-cli stopLitecoin server stopping 检查区块同步信息检查同步日志（刷屏）： 12345678910111213root@ubuntu:~/.litecoin$ cd testnet4/root@ubuntu:~/.litecoin/testnet3$ tail -f debug.log 2018-11-21T02:40:28Z net thread start2018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=12018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=02018-11-21T02:40:32Z 108 addresses found from DNS seeds2018-11-21T02:40:32Z dnsseed thread exit2018-11-21T02:40:36Z New outbound peer connected: version: 70015, blocks=1444366, peer=22018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=52018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=32018-11-21T02:40:41Z New outbound peer connected: version: 70015, blocks=1444366, peer=42018-11-21T02:40:48Z New outbound peer connected: version: 70015, blocks=1414448, peer=6....... 查询当前同步到的区块数： 1234root@ubuntu:~/.litecoin/testnet4$ curl --user litecoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getblockcount&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/Enter host password for user &apos;litecoinrpc&apos;:&#123;&quot;result&quot;:128631,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 查询测试网络中的总区块：http://testnet.litecointools.com/ 需要注意的是只有区块同步到最新才可以查到钱包余额，从头开始同步大概需要一天时间。 创建钱包地址123root@ubuntu:~$ curl --user litecoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnewaddress&quot;, &quot;params&quot;: [&quot;test&quot;] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/Enter host password for user &apos;litecoinrpc&apos;:&#123;&quot;result&quot;:&quot;QNuZnYa45hWRpsJz4SYwAEQfZS9UBc2j6L&quot;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 返回结果中的 “QNuZnYa45hWRpsJz4SYwAEQfZS9UBc2j6L” 即为新创建的莱特币钱包地址 查询余额 1omni@ubuntu:~$ curl --user litecoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getbalance&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 获取测试币在下面两个网站中可以获得少量的测试币，用来测试足够了： http://testnet.litecointools.com/ https://faucet.xblau.com/ 你可以在莱特币区块链浏览器查到余额 http://explorer.litecointools.com/address/QNuZnYa45hWRpsJz4SYwAEQfZS9UBc2j6L]]></content>
      <categories>
        <category>莱特币</category>
      </categories>
      <tags>
        <tag>测试环境</tag>
        <tag>莱特币</tag>
        <tag>ltc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu比特币测试环境搭建]]></title>
    <url>%2F2018%2F11%2F22%2F12.Ubuntu%E6%AF%94%E7%89%B9%E5%B8%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 安装bitcoin核心1234root@ubuntu:~# sudo apt-get install software-properties-commonroot@ubuntu:~# sudo apt-add-repository ppa:bitcoin/bitcoinroot@ubuntu:~# sudo apt-get updateroot@ubuntu:~# sudo apt-get install bitcoind 配置bitcoin参数123root@ubuntu:~$ mkdir .bitcoin #创建目录root@ubuntu:~$ cd .bitcoin/root@ubuntu:~$ vi bitcoin.conf 将下面信息全部复制，并修改rpcuser（RPC用户名），rpcpassword（RPC用户密码），rpcallowip（允许访问的ip地址）然后保存 1234567891011121314151617181920212223242526# Generated by https://jlopp.github.io/bitcoin-core-config-generator/# This config should be placed in following path:# ~/.bitcoin/bitcoin.conf# [rpc]# Accept command line and JSON-RPC commands.server=1# Username for JSON-RPC connectionsrpcuser=bitcoinrpc# Password for JSON-RPC connectionsrpcpassword=bitcoinrpc# Listen for JSON-RPC connections on this portrpcport=18332# Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), # a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option # can be specified multiple times.rpcallowip=192.168.1.178rpcallowip=192.168.1.179# Run this node on the Bitcoin Test Network.testnet=1 启动bitcoin程序12root@ubuntu:~/.bitcoin$ bitcoind -daemonBitcoin server starting 查看是否启动成功，需要输入上一步配置的密码，用户名bitcoinrpc改为你配置的用户名： 12root@ubuntu:~$ curl --user bitcoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnetworkinfo&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/Enter host password for user &apos;bitcoinrpc&apos;: 能返回下面的信息表示启动成功 1&#123;&quot;result&quot;:&#123;&quot;version&quot;:170000,&quot;subversion&quot;:&quot;/Satoshi:0.17.0/&quot;,&quot;protocolversion&quot;:70015,&quot;localservices&quot;:&quot;000000000000040d&quot;,&quot;localrelay&quot;:true,&quot;timeoffset&quot;:0,&quot;networkactive&quot;:true,&quot;connections&quot;:5,&quot;networks&quot;:[&#123;&quot;name&quot;:&quot;ipv4&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;ipv6&quot;,&quot;limited&quot;:false,&quot;reachable&quot;:true,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;,&#123;&quot;name&quot;:&quot;onion&quot;,&quot;limited&quot;:true,&quot;reachable&quot;:false,&quot;proxy&quot;:&quot;&quot;,&quot;proxy_randomize_credentials&quot;:false&#125;],&quot;relayfee&quot;:0.00001000,&quot;incrementalfee&quot;:0.00001000,&quot;localaddresses&quot;:[],&quot;warnings&quot;:&quot;&quot;&#125;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 停止bitcoin程序12root@ubuntu:~/.bitcoin/testnet3$ bitcoin-cli stopBitcoin server stopping 检查区块同步信息检查同步日志（刷屏）： 12345678910111213root@ubuntu:~/.bitcoin$ cd testnet3/root@ubuntu:~/.bitcoin/testnet3$ tail -f debug.log 2018-11-21T02:40:28Z net thread start2018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=12018-11-21T02:40:31Z New outbound peer connected: version: 70015, blocks=1444366, peer=02018-11-21T02:40:32Z 108 addresses found from DNS seeds2018-11-21T02:40:32Z dnsseed thread exit2018-11-21T02:40:36Z New outbound peer connected: version: 70015, blocks=1444366, peer=22018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=52018-11-21T02:40:37Z New outbound peer connected: version: 70015, blocks=1444366, peer=32018-11-21T02:40:41Z New outbound peer connected: version: 70015, blocks=1444366, peer=42018-11-21T02:40:48Z New outbound peer connected: version: 70015, blocks=1414448, peer=6....... 查询当前同步到的区块数： 1root@ubuntu:~$ curl --user bitcoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getblockcount&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 查询测试网络中的总区块：https://live.blockcypher.com/btc-testnet/ 需要注意的是只有区块同步到最新才可以查到钱包余额，从头开始同步大概需要一天时间。 创建钱包地址123root@ubuntu:~$ curl --user bitcoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getnewaddress&quot;, &quot;params&quot;: [&quot;test&quot;] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/Enter host password for user &apos;bitcoinrpc&apos;:&#123;&quot;result&quot;:&quot;2MyUBCnC2FvwX6ihegTVCKn1iKc5JeyEbKr&quot;,&quot;error&quot;:null,&quot;id&quot;:&quot;curltest&quot;&#125; 返回结果中的 “2MyUBCnC2FvwX6ihegTVCKn1iKc5JeyEbKr” 即为新创建的比特币钱包，以2开头表示是测试链的钱包地址，公链上的钱包地址一般是3开头 查询余额 1omni@ubuntu:~$ curl --user bitcoinrpc --data-binary &apos;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;:&quot;curltest&quot;, &quot;method&quot;: &quot;getbalance&quot;, &quot;params&quot;: [] &#125;&apos; -H &apos;content-type: text/plain;&apos; http://127.0.0.1:18332/ 获取测试币在下面两个网站中可以获得少量的测试币，用来测试足够了： https://coinfaucet.eu/en/btc-testnet/ http://bitcoinfaucet.uo1.net/send.php 你可以在比特币区块链浏览器查到余额：https://live.blockcypher.com/btc-testnet/address/2MtW8kA68TMrBLZb373WttjHbxfuRNdvHh7/]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>测试环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Google reCAPTCHA防止机器注册]]></title>
    <url>%2F2018%2F11%2F17%2F2.%E4%BD%BF%E7%94%A8Google%20reCAPTCHA%E9%98%B2%E6%AD%A2%E6%9C%BA%E5%99%A8%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 环境要求 能翻墙的电脑 域名 验证原理在谷歌recaptcha申请验证密钥，配置好服务器的域名，在需要验证的表单中嵌入google reCAPTCHA ,提交表单的时候将验证成功生成的响应码传给后台，后台将响应码post到谷歌的服务器验证地址，谷歌服务器将返回验证结果。生成响应码的页面域名必须是在谷歌页面配置的域名才能生成，只有ip也不行。google reCAPTCHA在web端有3种形式的验证 1.reCAPTCHA v3 在网页加载的时候生成响应码，不需要用户进行任何操作。生成响应码的时候会稍有延迟，比网页加载完成会慢一点，确保了他人利用程序获取html代码的方式不会获取响应码。加入reCAPTCHA v3 的页面会有类似下面的图标 2.reCAPTCHA v2 Checkbox 点击复选框 用户点击复选框进行验证成功后生成响应码，图标如下 3.reCAPTCHA v2 Invisible 自定义按钮 开发人员自定义验证的动作，验证成功后调用生成响应码的js代码生成响应码即可。图标与第1种相同。 申请密钥打开网页 https://www.google.com/recaptcha/admin 登录谷歌账号，在Label下面的输入项目名，然后选择reCAPTCHA的类型，点击Register即可注册完成，完成后可以得到Site key和Secret key。 配置域名在上一步注册好之后的页面底下Domains的框中输入需要验证的域名，只有输入的域名网站才有资格生成你的响应码。 插入前端代码在申请密钥完成的页面中按照给出的步骤Step1加入前端代码,比如如果是v3类型的验证码： 在html头部引入js 1&lt;script src=&apos;https://www.google.com/recaptcha/api.js?render=你的Site key&apos;&gt;&lt;/script&gt; 由于国家防火墙的原因，大陆的网站需要将js替换为国内的js地址（js是在客户端浏览器执行的，服务器能翻墙也不行） 1https://www.recaptcha.net/recaptcha/api.js 生成响应码 12345678910111213&lt;script&gt;grecaptcha.ready(function() &#123; grecaptcha.execute(&apos;你的Site key&apos;, &#123;action: &apos;action_name&apos;&#125;).then(function(token) &#123;// 将这个生成的token传给后台 &#125;);&#125;);&lt;/script&gt; 后台验证将前端传过来的响应码和你的Secret key发送到谷歌验证地址进行验证，判断返回数据即可 大陆的需要将验证链接 https://www.google.com/recaptcha/api/siteverify 改为 https://www.recaptcha.net/recaptcha/api/siteverify php示例： 123456789101112131415161718192021222324252627&lt;?phpfunction send_post($url, $post_data)&#123; $postdata = http_build_query($post_data); $options = array( &apos;http&apos; =&gt; array( &apos;method&apos; =&gt; &apos;POST&apos;, &apos;header&apos; =&gt; &apos;Content-type:application/x-www-form-urlencoded&apos;, &apos;content&apos; =&gt; $postdata, &apos;timeout&apos; =&gt; 15 * 60 // 超时时间（单位:s） ) ); $context = stream_context_create($options); $result = file_get_contents($url, false, $context); return $result;&#125; $post_data = array( &apos;secret&apos; =&gt; &apos;你的Secret key&apos;, &apos;response&apos; =&gt; $_POST[&quot;g-recaptcha-response&quot;] //前端传过来的响应码);$recaptcha_json_result = send_post(&apos;https://www.google.com/recaptcha/api/siteverify&apos;, $post_data); $recaptcha_result = json_decode($recaptcha_json_result); //在这里处理返回的值 var_dump($recaptcha_result); ?&gt; 隐藏reCAPTCHA图标根据reCAPTCHA的服务条款（即你必须同意），您必须告知游客有关网站上的验证码实现 但是有时候在手机页面这么大的一个图标确实会影响到页面效果，不得不隐藏的时候可以在前端做一下处理 设置data-badge属性inline 1&lt;button type=&quot;submit&quot; data-sitekey=&quot;your_site_key&quot; data-callback=&quot;onSubmit&quot; data-badge=&quot;inline&quot; /&gt; 添加CSS 123.grecaptcha-badge &#123; display: none; &#125;]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Google reCAPTCHA</tag>
        <tag>防注册机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMP下配置免费SSL安全证书(https)]]></title>
    <url>%2F2018%2F11%2F17%2F6.LNMP%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%85%8D%E8%B4%B9SSL%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6(https)%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 环境要求 LNMP 域名 安装依赖1234$ cd /root/$ wget https://dl.eff.org/certbot-auto --no-check-certificate$ chmod +x ./certbot-auto$ ./certbot-auto -n 生成证书注意将 www.vpser.net 替换成你的域名 单域名生成证书： 1$ ./certbot-auto certonly --email youemail@vpser.net --agree-tos --no-eff-email --webroot -w /home/wwwroot/www.vpser.net -d www.vpser.net 多域名单目录生成单证书：(即一个网站多个域名使用同一个证书) 1$ ./certbot-auto certonly --email youemail@vpser.net --agree-tos --no-eff-email --webroot -w /home/wwwroot/www.vpser.net -d www.vpser.net -d bbs.vpser.net 多域名多目录生成一个证书：(即一次生成多个域名的一个证书) 1$ ./certbot-auto certonly --email youemail@vpser.net --agree-tos --no-eff-email --webroot -w /home/wwwroot/www.vpser.net -d www.vpser.net -d bbs.vpser.net -w /home/wwwroot/lnmp.org -d www.lnmp.org -d lnmp.org 提示以下信息表示生成成功 12345678910IMPORTANT NOTES:- Congratulations! Your certificate and chain have been saved at/etc/letsencrypt/live/www.vpser.net/fullchain.pem. Your cert willexpire on 2016-10-01. To obtain a new or tweaked version of thiscertificate in the future, simply run certbot-auto again. Tonon-interactively renew *all* of your certificates, run&quot;certbot-auto renew&quot;- If you like Certbot, please consider supporting our work by:Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donateDonating to EFF: https://eff.org/donate-le 生成的证书会存在：/etc/letsencrypt/live/www.vpser.net/ 目录下，检查是否有两个.pom的证书文件 修改配置 下载配置文件并替换掉所有的www.example.net为你的域名 链接：https://pan.baidu.com/s/1HC1ErFjtoDe8akzzWys29A 密码：i2fi 上传至/usr/local/nginx/conf/vhost 并替换原来的文件 执行：/etc/init.d/nginx reload 重新载入配置使其生效 到这里你的域名应该就已经变成https了 证书续期因为证书只有90天，所以建议使用crontab进行自动续期，间隔5天就可以了，不能太频繁 12$ crontab -e0 3 */5 * * /root/certbot-auto renew --disable-hook-validation --renew-hook &quot;/etc/init.d/nginx reload&quot; 本文参考：https://www.vpser.net/build/letsencrypt-free-ssl.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊代币开发]]></title>
    <url>%2F2018%2F11%2F14%2F8.%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%A3%E5%B8%81%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 环境要求 以太坊公链或私有链 一个有以太币的钱包：用于支付手续费和接收代币 EthereumWallet客户端 部署合约在Ethereum Wallet客户端中点击 CONTRACTS =&gt; DEPLOY NEW CONTRACT ,然后FROM填你的以太坊地址，一般会自动填上。在下方SOLIDITY CONTRACT SOURCE CODE的编辑框中填入官方的创建代币的合约代码 官方代码的地址：https://ethereum.org/token ，这个代码复制到Ethereum Wallet会报”Defining constructors as functions with the same name as the contract is deprecated.”的错误，把第5行代码中的合约名字 TokenERC20 改为 其他名称即可，例如 Token。 另外如果代币的小数位数不是18位，需要修改代码第9行中的 public decimals 为你需要的小数位数 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158pragma solidity ^0.4.16;interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; &#125;contract Token &#123; // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes &#125; /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal &#123; // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; &#125; /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123; tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) &#123; spender.receiveApproval(msg.sender, _value, this, _extraData); return true; &#125; &#125; /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; &#125; /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&apos;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; &#125;&#125; 将代码复制过去之后，发现后边会出现下拉框，选择“Token”(就是你合约的名字)，然后点击最下面的“DEPLOY”，在弹出框中输入账号密码等待交易完成。 创建代币 点击“CONTRACT”会发现在灰色背景的栏目“Custom Contracts”中多了刚刚创建的合约，点击它进入这个合约。 在界面的右下角下拉框选择“Token ERC 20”,下面的输入框分别填写代币的发行量、具体名称 (比如Ethereum)，代币符号(就是代币的单位，比如ETH)，然后点击“EXECUTE”按钮，输入账号密码等待交易完成。 交易完成后点击“CONTRACT”拉到最下面点击刚刚创建的代币，填写代币的名称、符号和位数，点击OK保存好代币的信息。 首页点击你创建代币的钱包地址，会发现以太币余额下面多出一行代币的余额。鼠标移上去点击Send即可发送代币交易。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>代币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下以太坊私有链搭建]]></title>
    <url>%2F2018%2F11%2F14%2F3.Windows%E4%B8%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com Geth的下载安装本文在64位windows10环境下搭建，其他系统或许会略有不同。首先在官方网站https://geth.ethereum.org/downloads/ ，国内镜像http://ethfans.org/wikis/Ethereum-Geth-Mirror下载geth的windows端，下载完成后一直点下一步安装即可。 准备创世区块文件在任何一个目录下创建 privatechain 文件夹，这里在D盘下创建。然后在privatechain 文件夹中创建data文件夹和genesis.json文件，打开genesis.json文件将以下代码复制到文件中并保存 123456789101112&#123;&quot;nonce&quot;: &quot;0x0000000000000042&quot;,&quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;difficulty&quot;: &quot;0x400&quot;,&quot;alloc&quot;: &#123;&#125;,&quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;,&quot;timestamp&quot;: &quot;0x0&quot;,&quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;extraData&quot;: &quot;0x&quot;,&quot;gasLimit&quot;: &quot;0x8000000&quot;,&quot;config&quot;: &#123;&#125;&#125; 初始化创世区块打开cmd，进入到privatechain目录下然后执行下面的命令即可完成创世区块的初始化 1234567891011$ geth --datadir data init genesis.json INFO [10-24|14:12:56] Maximum peer count ETH=25 LES=0 total=25INFO [10-24|14:12:56] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\chaindata cache=16 handles=16INFO [10-24|14:12:56] Writing custom genesis blockINFO [10-24|14:12:56] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [10-24|14:12:56] Successfully wrote genesis state database=chaindata hash=6231b0 …a0300bINFO [10-24|14:12:56] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\lightchaindata cache=16 handles=16INFO [10-24|14:12:56] Writing custom genesis blockINFO [10-24|14:12:56] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [10-24|14:12:56] Successfully wrote genesis state database=lightchaindata hash=6231b0…a0300b 启动私有链打开cmd，进入到privatechain目录下然后执行下面的命令即可启动私有链，命令中的ip地址请自行换成你本机的ip，–datadir换成自己的私有链所在的目录 1$ geth --port 3000 --networkid 15 --maxpeers=3 --rpc --rpcport 8545 --rpcaddr 127.0.0.1 --rpccorsdomain &quot;*&quot; --rpcapi=&quot;db,eth,web3,personal,admin,txpool&quot; --gcmode archive console 得到以下信息，表示已经启动私有链并进入geth console 123456789101112131415161718192021222324INFO [10-24|14:16:13] Maximum peer count ETH=3 LES=0 total=3INFO [10-24|14:16:13] Starting peer-to-peer node instance=Geth/v1.8.3-stable-329ac18e/windows-amd64/go1.10INFO [10-24|14:16:13] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\chaindata cache=768 handles=1024WARN [10-24|14:16:13] Upgrading database to use lookup entriesINFO [10-24|14:16:13] Database deduplication successful deduped=0INFO [10-24|14:16:13] Initialised chain configuration config=&quot;&#123;ChainID: &lt;nil&gt; Homestead: &lt;nil&gt; DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: &lt;nil&gt; EIP158: &lt;nil&gt; Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown&#125;&quot;INFO [10-24|14:16:13] Disk storage enabled for ethash caches dir=D:\\Ethereum\\data\\geth\\ethash count=3INFO [10-24|14:16:13] Disk storage enabled for ethash DAGs dir=C:\\Users\\Jian\\AppData\\Ethash count=2INFO [10-24|14:16:13] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=15INFO [10-24|14:16:13] Loaded most recent local header number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Loaded most recent local full block number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Loaded most recent local fast block number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Regenerated local transaction journal transactions=0 accounts=0INFO [10-24|14:16:13] Starting P2P networkingINFO [10-24|14:16:16] UDP listener up self=enode://9ab0834740439ca962b4e2b43d85f555cff7585c0b4bf3a076f16a95ad6037beab7f8b9f2b9691c60c128cf212f38fe469930016cde71574b84733457ed45813@[::]:3000INFO [10-24|14:16:16] RLPx listener up self=enode://9ab0834740439ca962b4e2b43d85f555cff7585c0b4bf3a076f16a95ad6037beab7f8b9f2b9691c60c128cf212f38fe469930016cde71574b84733457ed45813@[::]:3000INFO [10-24|14:16:16] IPC endpoint opened url=\\\\.\\pipe\\geth.ipcINFO [10-24|14:16:16] HTTP endpoint opened url=http://192.168.1.168:8545 cors=* vhosts=localhostWelcome to the Geth JavaScript console!instance: Geth/v1.8.3-stable-329ac18e/windows-amd64/go1.10 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 启动私有链之后就可以在控制台中进行账号操作和挖矿等相关操作了 ，启动命令加上 –gcmode archive 表示将区块信息及时保存，不然重启geth后区块数据可能会丢失，还原到上次启动之前的状态。 账号和挖矿等操作请参见我的另一篇文章：Ubuntu以太坊私有链搭建 图形化客户端除了使用命令行操作，以太坊还提供了图形界面Mist和Ethereum Wallet，两者功能上相同，下载其中一个即可 下载地址：https://github.com/ethereum/mist/releases/ ，windows建议下载.zip免安装压缩版，解压就可以用了。exe后缀的启动程序时好像会一直卡在“Downloading new node”的启动页面。 国内无法访问的话可以到以太坊爱好者的网站下载：http://ethfans.org/wikis/Wallet-Mirror 安装完成打开程序，第一次打开需要一段时间。客户端默认是同步公链区块的，所以想要在图形界面进入私有链，必须先在命令行启动私有链再打开客户端。进入私有链客户端启动界面的右上角会有PRIVATE-NET标记，进入程序后中间也有Private-net的标记。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>私有链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F10%2F1.Hello%20World%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com Hello,大家好，我是本博客的作者陈进坚。欢迎来到我的个人博客，从今天起我将不定时在博客和CSDN同步发布技术文档。主要是关于PHP,Golang和区块链方面的开发技术，欢迎大家关注收藏~ 本站是基于Hexo在github上搭建的免费博客，建站步骤和主题参考： https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/ 除了在本博客、简书和本人的CSDN博客中发布，所有未经授权的文章禁止转载哦，如果大家看到我的文章未授权被转载盗用了请联系我，当然，如果觉得我的文章不错想要转载可以邮箱联系我，可以提供Markdown源文件哦。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>第一篇文章</tag>
        <tag>关于博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu以太坊节点搭建]]></title>
    <url>%2F2018%2F11%2F10%2F10.Ubuntu%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%8A%82%E7%82%B9%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 安装Geth1234root@dserv834-mtl8:~# apt-get install software-properties-commonroot@dserv834-mtl8:~# add-apt-repository -y ppa:ethereum/ethereumroot@dserv834-mtl8:~# apt-get updateroot@dserv834-mtl8:~# apt-get install ethereum 安装后查询到geth版本即为安装成功 12345678910111213root@dserv834-mtl8:~# which geth ###查看geth路径/usr/bin/gethroot@dserv834-mtl8:~# geth versionGethVersion: 1.8.12-stableGit Commit: 37685930d953bcbe023f9bc65b135a8d8b8f1488Architecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.10Operating System: linuxGOPATH=GOROOT=/usr/lib/go-1.10 创建Geth启动/停止脚本查看本地IP地址，得到内网地址为173.209.49.10 12345678910root@dserv834-mtl8:~# ifconfig -aeno1 Link encap:Ethernet HWaddr ac:1f:6b:82:8c:f4 inet addr:173.209.49.10 Bcast:173.209.49.15 Mask:255.255.255.248 inet6 addr: fe80::ae1f:6bff:fe82:8cf4/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:164109642 errors:0 dropped:10 overruns:0 frame:0 TX packets:143189840 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:87852826043 (87.8 GB) TX bytes:35500135072 (35.5 GB) Memory:df200000-df27ffff 创建geth启动脚本starteth.sh，将第二行开始的脚本复制保存，需要修改rpcaddr的ip，datadir可以省略，一般将datadir改为大容量的数据盘目录 1234root@dserv834-mtl8:~# vi starteth.sh #!/bin/bashnohup geth --rpcaddr &quot;173.209.49.10&quot; --rpc --rpccorsdomain=&quot;*&quot; --datadir &quot;/data/ethereum&quot; &gt;&gt; geth.log 2&gt;&amp;1 &amp; 创建geth停止脚本stopeth.sh，将第二行开始的脚本复制保存 123456789root@dserv834-mtl8:~# more stopeth.sh #!/bin/bashPIDS=`ps -ef |grep geth |grep -v grep | awk &apos;&#123;print $2&#125;&apos;`if [ &quot;$PIDS&quot; != &quot;&quot; ]; then kill -9 $PIDSelse echo `date +%F&quot; &quot;%H:%M:%S` &quot;Geth is NOT runing!&quot;fi 配置脚本执行权限 1234root@dserv834-mtl8:~# chmod u+x st*.shroot@dserv834-mtl8:~# ls -la *.sh-rwxr--r-- 1 root root 95 Jul 10 11:41 starteth.sh-rwxr--r-- 1 root root 171 Jul 11 21:49 stopeth.sh 启动geth程序同步区块数据 启动Geth开始同步数据，通过查看geth.log来监控Geth的同步情况 1234567root@dserv834-mtl8:~# ./starteth.shroot@dserv834-mtl8:~# tail -f geth.logINFO [07-11|21:51:06.609] Imported new chain segment blocks=1 txs=55 mgas=7.992 elapsed=368.336ms mgasps=21.697 number=5948083 hash=14c024…a9d1bb cache=267.07mBINFO [07-11|21:51:10.051] Imported new chain segment blocks=1 txs=43 mgas=7.987 elapsed=105.155ms mgasps=75.959 number=5948084 hash=ede212…56e3b8 cache=267.22mBINFO [07-11|21:51:13.530] Imported new chain segment blocks=1 txs=133 mgas=7.961 elapsed=431.951ms mgasps=18.431 number=5948085 hash=533343…c40637 cache=267.59mBINFO [07-11|21:51:17.785] Imported new chain segment blocks=1 txs=51 mgas=7.982 elapsed=304.528ms mgasps=26.211 number=5948086 hash=8918b3…263ea8 cache=268.06mB.......... 一般情况下geth从0开始同步需要3天左右的时间，由服务器的带宽和性能决定，可以购买境外的服务器，如香港的阿里云。 判断同步完成geth在同步的时候，通过geth console查看eth.blockNumber命令查询区块高度，如果得到的结果是0，说明没有同步完成，如果得到最新的区块，说明已经同步到最新区块了。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>ethereum</tag>
        <tag>节点搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[geth常用操作]]></title>
    <url>%2F2018%2F11%2F10%2F9.geth%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 修改钱包密码其中–datadir参数是你的geth目录，这个目录里面包含geth和keystore目录 1$ geth account update &quot;aad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae&quot; --datadir &quot;./data0&quot; 先输入旧的密码解锁 12Unlocking account 0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae | Attempt 1/3Passphrase:旧的密码 再输入两次新的密码，按回车完成 1234Unlocked account address=0xAAd71aAAEF7ce2CA356B9B80d0c385eeCD8eD1AePlease give a new password. Do not forget this password.Passphrase:新的密码Repeat passphrase:再次输入新的密码 进入geth console解锁钱包检验新的密码 1234567$ geth --port 3000 --networkid 15 --datadir=&quot;./data0&quot; --maxpeers=3 --rpc --rpcport 8545 --rpccorsdomain &quot;*&quot; console&gt; personal.unlockAccount(&quot;0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae&quot;)Unlock account 0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1aePassphrase:true 修改默认账号coinbasegeth console中执行 1&gt; miner.setEtherbase(&quot;0xa91Ae941e92eb6Fa78FE0d8215F01cbE6b7C014c&quot;) 覆盖交易当发送的交易还没有交易完成时，以太坊是可以用新的交易将那笔未完成的交易覆盖的，当交易的数量为0时表示将交易覆盖取消。当然，第二笔交易的gasPrice需要比被覆盖掉的高。 nonce的作用：每个钱包地址发送都会产生一个nonce值，默认从0开始，这个地址每发送一笔交易nonce+1,类似数据库的自增id,覆盖交易就是发送相同nonce的一笔交易，将该笔交易覆盖。当nonce比之前交易成功的nonce小，交易会被直接拒绝；当nonce比之前交易成功的nonce大2或以上，就是两笔nonce不连续，那么交易会一直等待。比如说上一笔交易成功的交易nonce为4，这次交易的nonce为6，那么在nonce为5的交易完成之后，nonce为6以及大于6的交易都会暂停，不会交易成功。 1.查询该钱包当前的nonce 12&gt; eth.getTransactionCount(&apos;0xa94183a1d6982a9703791Ec1DfF0093746030A78&apos;)1827 说明从nonce为0到1826的交易都成功了 2.发送指定nonce的交易 假设nonce为1827的交易已经发送，但是未交易完成，我们可以将这笔交易覆盖 1&gt;eth.sendTransaction(&#123;from:eth.coinbase,to:&quot;0x8E9e5Db2Dd8B468CC9edC1f72Dd2948828d5285a&quot;,value:web3.toWei(0.01,&apos;ether&apos;),gasPrice:web3.toWei(0.000000004,&apos;ether&apos;),nonce:1827&#125;) 如果1826和1828之间缺了一笔1827，造成交易无法继续，可以用同样的方法发送交易补全nonce为连续的数，当然发送的币量可以为0 Unable to attach to remote geth问题如果使用geth attach命令打开控制台出现：Unable to attach to remote geth: dial unix \/home\/www\/.ethereum\/geth.ipc: connect: permission denied”]，一般为权限问题， 输入下面的命令修改权限为www即可(LNMP环境)，geth.ipc的路径根据实际路径修改： 12cd /ethdb/ethereum/chown -R www:www geth.ipc]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP开发规范]]></title>
    <url>%2F2018%2F11%2F10%2F5.PHP%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 一、摘要&emsp;&emsp;这是一份旨在增强团队的开发协作，提高代码质量和打造开发基石的编码风格规范。当一个团队开始指定并实行编码规范的话，错误就会变得更加显而易见。如果一段特定的代码不符合规范的话，它有可能只是代码风格错误，而也有可能会是 bug，更可能出现安全问题。早期指定规范就使得代码审核得以更好的开展，并且可以更精确的地定位到错误。只要开发者们能够保证源代码源文件都严格遵循规范，那接下来的维护工作就可以变得轻松简单。总之，我们的目标就是遵循同一套编码规范，不管有多少人共同参与同一项目，都可以确保每一行代码都像是同一个人编写的，每一个功能都是安全的。 二、PHP相关命名规范2.1 方法命名&emsp;&emsp;方法，指的是在类中定义的函数，方法的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 getUserName( )，_parseType( )，通常下划线开头的方法属于私有方法； 2.2 函数命名&emsp;&emsp;函数是指不在类中定义的函数，例如在公共文件中的函数。函数的命名使用小写字母和下划线的方式，例如 get_client_ip( )； 2.3 变量（属性）命名&emsp;&emsp;变量，也叫属性。属性的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 tableName、_instance，通常下划线开头的属性属于私有属性； 2.4 常量命名&emsp;&emsp;常量以大写字母和下划线命名，例如 HAS_ONE和 MANY_TO_MANY； 2.5 配置参数命名&emsp;&emsp;配置参数以大写字母和下划线命名，例如 HTML_CACHE_ON = 1； 三、数据库相关命名规范3.1 数据库命名&emsp;&emsp;数据库的命名一般采用小写字母命名，如 testdb; 3.2 数据表命名&emsp;&emsp;数据表命名格式为 表前缀+下划线（_）+表名 组合方式命名。同一数据库表前缀相同，且使用小写字母命名，表名使用小写字母和下划线命名。例如 wll_setting_record，其中wll为前缀，setting_record为表名。 3.3 字段命名&emsp;&emsp;字段的命名采用小写字母和下划线命名，如 coin_type。 四、禁止使用的命名方式4.1 无意义的命名&emsp;&emsp;例如：$abcd、qqqqqqq()、test1111111等，命名应该使用对应的英文翻译； 4.2 拼音命名&emsp;&emsp;例如添加用户（tjyh）或中英混合的（tjUser），如果使用这种方式，其他开发人员会很难看得懂，加大维护难度。 4.3 单字母命名&emsp;&emsp;ThinkPHP中封装了很多名称为单字母的快捷方法，例如A( )、C( )、M( )。如果再定义可能会发生冲突。 五、注释规范5.1 方法和函数&emsp;&emsp;在方法和函数的上一行必须用双斜线注释注明该方法或函数的功能，在难以理解的代码语句后面适当添加注释说明，例如：123456789101112131415161718192021// 短信宝短信 http://www.smsbao.com/public function smsbao($username, $password, $moble, $content)&#123; $url = &apos;http://api.smsbao.com/sms?u=&apos; . $username . &apos;&amp;p=&apos; . $password . &apos;&amp;m=&apos; . $moble . &apos;&amp;c=&apos; . $content; if (function_exists(&apos;file_get_contents&apos;)) &#123; $file_contents = file_get_contents($url); &#125; else &#123; $ch = curl_init(); $timeout = 5; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout); $file_contents = curl_exec($ch); curl_close($ch); &#125; if ($file_contents &gt; 0) &#123; return [$file_contents]; // 失败 &#125; else &#123; return [$file_contents, 1]; //成功 &#125;&#125; 5.2 配置参数&emsp;&emsp;在配置文件中的参数设置必须注明变量含义，例如：12345&apos;DB_TYPE&apos; =&gt; &apos;mysql&apos;, // 数据库类型&apos;DB_HOST&apos; =&gt; &apos;localhost&apos;, // 服务器地址&apos;DB_NAME&apos; =&gt; &apos;wlldb&apos;, // 数据库名&apos;DB_USER&apos; =&gt; &apos;root&apos;, // 用户名&apos;DB_PWD&apos; =&gt; &apos;root&apos;, // 密码 六、编码风格规范6.1 禁止出现多行空格&emsp;&emsp;如果不是特殊需要，在代码文件中禁止出现多行空格，例如下面这种是不允许的：12345678910//公共方法public function common()&#123; $name=&apos;tom&apos;; //定义姓名 $this-&gt;assign(&apos;name&apos;,$name); $this-&gt;display();&#125; 6.2 缩进&emsp;&emsp;代码中需要适当的缩进，否则会加大维护难度。 6.3 目录结构&emsp;&emsp;一般框架都是有默认的目录结构，非特殊情况不允许修改目录结构，例如thinkphp默认的是MVC架构的目录结构，避免由于更改目录结构带来的维护困难。Controller文件放在Controller目录 中，Model文件放在Model目录中，View文件放在View目录中，不要随意更改目录的位置和目录名称。 七、安全7.1.1 输入框&emsp;&emsp;所有的输入框请设置最大长度，必填项请做必填的限制。例如帐号CHN00000001,只能输入11位，那么最大输入长度只能为11，并且添加required=”required”属性。 7.1.2 文本编辑器&emsp;&emsp;前台页面尽量不要使用富文本编辑器，因为富文本编辑器可以输入代码，有很大的安全隐患。如果要使用，必须对提交内容进行过滤，例如使用htmlspecialchars()进行过滤。 7.2 后台接收参数&emsp;&emsp;PHP从表单获取url中获取参数必须进行字段类型判断。例如接收数字的参数不能含有其他字符，只能是数字，建议编写公共的检查接收post和get参数的函数，对每一个参数值进行验证，防止注入恶意代码。&emsp;&emsp;接收长篇内容的变量，例如留言内容等变量时，必须进行特殊字符的过滤操作。比如strip_tags()、htmlspecialchars()、htmlentities()等函数可以起作用，防止用户注入恶意代码进行跨站脚本攻击。 7.3 数据库查询&emsp;&emsp;数据库查询语句禁止直接使用sql语句和传递的参数直接执行，例如下面这种的写法是禁止使用的：1234$id = 1;$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where(&apos;id=&apos;.$id)-&gt;select(); //错误写法1$User-&gt;where(&quot;id=$id&quot;)-&gt;select(); //错误写法2 &emsp;&emsp;如果传递过来的参数含有SQL注入代码，这两种写法都是非常危险的。正确的写法有以下两种：（1）数组条件，例如：123$where[&apos;id&apos;] = 1;$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where($where)-&gt;select(); 或者12$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where([&apos;id&apos;=&gt;1])-&gt;select(); （2）预处理机制，例如：12$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where(&quot;id=%d&quot;,$id)-&gt;select(); 7.4 权限控制&emsp;&emsp;凡是需要登录之后才可以访问的页面加载页面之前必须做好登录检测，登录超时的必须重新登录。需要权限访问的页面和功能必须做好权限控制和检测。 7.5 越权访问&emsp;&emsp;比如邮件列表的页面 http://119.28.56.83/user/xq/id/5 ，只需要修改最后面的邮件id就可以直接访问的，必须加入当前用户判断，只能查看自己的邮件，禁止越权访问。 7.6 数据导出&emsp;&emsp;数据的导出和下载必须做好登录状态验证和权限的控制，没有权限或没有登录的禁止下载导出。 7.7 防暴力破解&emsp;&emsp;暴力破解是指使用数据字典等枚举方式逐个帐号进行密码的尝试破解，为了防止这种破解，在登录、注册、找回密码等页面必须设置好图形验证码或者其他验证，最好是做好错误次数的限制，例如密码输错5次，一个小时内禁止登录等。 7.8 短信邮件安全&emsp;&emsp;用到发送短信和发送邮件的页面，必须设置图形验证码，点击发送之前，验证图形验证码正确后再发送。最好限制每个手机号每天的发送数量。 7.9 密码明文传输&emsp;&emsp;一般在前端页面表单提交的时候，用户输入密码是明文的。在服务器没有配置SLL证书(https)的情况下，必须先进行加密操作再提交，参数传递到后台接收后再进行解密操作。服务器配置SLL证书(https)可以自动进行加密传输，安全性更高。 7.10 使用外部文件&emsp;&emsp;在前端页面中，禁止引入其他网站的静态文件（javascript、css、网络图片等），如果需要用到，必须下载到本地，使用相对地址引入文件。使用本地静态文件的优点：加载更快，安全，确保不失效。 7.11 密码安全&emsp;&emsp;禁止将明文密码存储在数据库中，所有密码必须加密处理，防止用户数据被导出造成密码泄露。禁止在日志、调试信息文件、cookies中记录密码口令、银行账号、通信内容等敏感数据。为了保障帐号的安全，所有密码的长度强制限制在6位以上。 八、并发和大流量处理8.1 重复提交&emsp;&emsp;为了防止用户在提交表单时重复提交，表单必须设置提交验证。例如商城提交订单时，必须防止用户重复提交。Thinkphp框架中提供表单令牌的功能可以防止重复提交，原生php也可以在打开页面前生成token，并保存在session，然后将token传递到页面表单字段，在表单提交时将token一起提交，在后台接收时验证token，验证后销毁session的保存的token。 8.2 session&emsp;&emsp;一次性验证的session使用后必须销毁，例如短信验证，表单验证等，防止一次性session被重复利用，例如在用户在注册时如果不销毁短信验证码session，用户可以用同一个短信验证码注册多个账号。 8.3 并发&emsp;&emsp;并发处理会经常碰到，例如商城秒杀功能，如果不做好并发处理，那么同一件商品江湖被多个用户购买。并发的处理方案可以考虑以下方案：（1）锁表操作，缺点是并发数比较大的时候回造成系统卡顿。（2）队列（3）负载均衡（4）数据库读写分离 (5) 使用Nginx作为http服务器 8.4 缓存&emsp;&emsp;对于经常需要访问的数据库数据，可以使用缓存来提高访问速度，读取缓存文件数据币数据库查询要快得多，主要缓存技术有：（1）Thinkphp自带的S()方法（2）文件读写，这个方法主意数据的加密确保安全性（3）Memcached]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang时间与时间戳的获取和转换]]></title>
    <url>%2F2018%2F11%2F10%2F4.Golang%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 获取时间戳需要 import “time” 包 12345678910//获取当前时间戳，单位s,打印结果:1491888244timeUnix:=time.Now().Unix() //获取当前时间戳，单位纳秒,打印结果：1491888244752784461timeUnixNano:=time.Now().UnixNano() //获取指定时间的时间戳loc, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;) //设置时区timeStr, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, &quot;2018-07-11 15:07:58&quot;, loc) //2006-01-02 15:04:05是转换的格式，如php的&quot;Y-m-d H:i:s&quot;，&quot;2018-07-11 15:07:58&quot;才是真正要转换的时间fmt.Println(timeStr.Unix()) //打印结果：1531292878 获取时间需要 import “time” 包 123456789t := time.Now() //2018-10-22 06:59:39.399239964 +0000 UTCy := t.Year() //年m := t.Month() //月d := t.Day() //日h := t.Hour() //小时i := t.Minute() //分钟s := t.Second() //秒fmt.Println(y, m, d, h, i, s) //2018 July 11 15 24 59]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
