<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[以太坊代币开发]]></title>
    <url>%2F2018%2F11%2F14%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%A3%E5%B8%81%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 环境要求 以太坊公链或私有链 一个有以太币的钱包：用于支付手续费和接收代币 EthereumWallet客户端 部署合约在Ethereum Wallet客户端中点击 CONTRACTS =&gt; DEPLOY NEW CONTRACT ,然后FROM填你的以太坊地址，一般会自动填上。在下方SOLIDITY CONTRACT SOURCE CODE的编辑框中填入官方的创建代币的合约代码 官方代码的地址：https://ethereum.org/token ，这个代码复制到Ethereum Wallet会报”Defining constructors as functions with the same name as the contract is deprecated.”的错误，把第5行代码中的合约名字 TokenERC20 改为 其他名称即可，例如 Token。 另外如果代币的小数位数不是18位，需要修改代码第9行中的 public decimals 为你需要的小数位数 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158pragma solidity ^0.4.16;interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; &#125;contract Token &#123; // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address =&gt; uint256) public balanceOf; mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes &#125; /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal &#123; // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) &#123; _transfer(msg.sender, _to, _value); return true; &#125; /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; &#125; /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123; tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) &#123; spender.receiveApproval(msg.sender, _value, this, _extraData); return true; &#125; &#125; /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; &#125; /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&apos;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; &#125;&#125; 将代码复制过去之后，发现后边会出现下拉框，选择“Token”(就是你合约的名字)，然后点击最下面的“DEPLOY”，在弹出框中输入账号密码等待交易完成。 创建代币 点击“CONTRACT”会发现在灰色背景的栏目“Custom Contracts”中多了刚刚创建的合约，点击它进入这个合约。 在界面的右下角下拉框选择“Token ERC 20”,下面的输入框分别填写代币的发行量、具体名称 (比如Ethereum)，代币符号(就是代币的单位，比如ETH)，然后点击“EXECUTE”按钮，输入账号密码等待交易完成。 交易完成后点击“CONTRACT”拉到最下面点击刚刚创建的代币，填写代币的名称、符号和位数，点击OK保存好代币的信息。 首页点击你创建代币的钱包地址，会发现以太币余额下面多出一行代币的余额。鼠标移上去点击Send即可发送代币交易。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>代币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下以太坊私有链搭建]]></title>
    <url>%2F2018%2F11%2F14%2FWindows%E4%B8%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com Geth的下载安装本文在64位windows10环境下搭建，其他系统或许会略有不同。首先在官方网站https://geth.ethereum.org/downloads/ ，国内镜像http://ethfans.org/wikis/Ethereum-Geth-Mirror下载geth的windows端，下载完成后一直点下一步安装即可。 准备创世区块文件在任何一个目录下创建 privatechain 文件夹，这里在D盘下创建。然后在privatechain 文件夹中创建data文件夹和genesis.json文件，打开genesis.json文件将以下代码复制到文件中并保存 123456789101112&#123;&quot;nonce&quot;: &quot;0x0000000000000042&quot;,&quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;difficulty&quot;: &quot;0x400&quot;,&quot;alloc&quot;: &#123;&#125;,&quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;,&quot;timestamp&quot;: &quot;0x0&quot;,&quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;extraData&quot;: &quot;0x&quot;,&quot;gasLimit&quot;: &quot;0x8000000&quot;,&quot;config&quot;: &#123;&#125;&#125; 初始化创世区块打开cmd，进入到privatechain目录下然后执行下面的命令即可完成创世区块的初始化 1234567891011$ geth --datadir data init genesis.json INFO [10-24|14:12:56] Maximum peer count ETH=25 LES=0 total=25INFO [10-24|14:12:56] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\chaindata cache=16 handles=16INFO [10-24|14:12:56] Writing custom genesis blockINFO [10-24|14:12:56] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [10-24|14:12:56] Successfully wrote genesis state database=chaindata hash=6231b0 …a0300bINFO [10-24|14:12:56] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\lightchaindata cache=16 handles=16INFO [10-24|14:12:56] Writing custom genesis blockINFO [10-24|14:12:56] Persisted trie from memory database nodes=0 size=0.00B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [10-24|14:12:56] Successfully wrote genesis state database=lightchaindata hash=6231b0…a0300b 启动私有链打开cmd，进入到privatechain目录下然后执行下面的命令即可启动私有链，命令中的ip地址请自行换成你本机的ip，–datadir换成自己的私有链所在的目录 1$ geth --port 3000 --networkid 15 --datadir=&quot;data&quot; --maxpeers=3 --rpc --rpcport 8545 --rpcaddr 127.0.0.1 --rpccorsdomain &quot;*&quot; --rpcapi=&quot;db,eth,web3,personal,admin,txpool&quot; console 得到以下信息，表示已经启动私有链并进入geth console 123456789101112131415161718192021222324INFO [10-24|14:16:13] Maximum peer count ETH=3 LES=0 total=3INFO [10-24|14:16:13] Starting peer-to-peer node instance=Geth/v1.8.3-stable-329ac18e/windows-amd64/go1.10INFO [10-24|14:16:13] Allocated cache and file handles database=D:\\Ethereum\\data\\geth\\chaindata cache=768 handles=1024WARN [10-24|14:16:13] Upgrading database to use lookup entriesINFO [10-24|14:16:13] Database deduplication successful deduped=0INFO [10-24|14:16:13] Initialised chain configuration config=&quot;&#123;ChainID: &lt;nil&gt; Homestead: &lt;nil&gt; DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: &lt;nil&gt; EIP158: &lt;nil&gt; Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown&#125;&quot;INFO [10-24|14:16:13] Disk storage enabled for ethash caches dir=D:\\Ethereum\\data\\geth\\ethash count=3INFO [10-24|14:16:13] Disk storage enabled for ethash DAGs dir=C:\\Users\\Jian\\AppData\\Ethash count=2INFO [10-24|14:16:13] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=15INFO [10-24|14:16:13] Loaded most recent local header number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Loaded most recent local full block number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Loaded most recent local fast block number=0 hash=6231b0…a0300b td=1024INFO [10-24|14:16:13] Regenerated local transaction journal transactions=0 accounts=0INFO [10-24|14:16:13] Starting P2P networkingINFO [10-24|14:16:16] UDP listener up self=enode://9ab0834740439ca962b4e2b43d85f555cff7585c0b4bf3a076f16a95ad6037beab7f8b9f2b9691c60c128cf212f38fe469930016cde71574b84733457ed45813@[::]:3000INFO [10-24|14:16:16] RLPx listener up self=enode://9ab0834740439ca962b4e2b43d85f555cff7585c0b4bf3a076f16a95ad6037beab7f8b9f2b9691c60c128cf212f38fe469930016cde71574b84733457ed45813@[::]:3000INFO [10-24|14:16:16] IPC endpoint opened url=\\\\.\\pipe\\geth.ipcINFO [10-24|14:16:16] HTTP endpoint opened url=http://192.168.1.168:8545 cors=* vhosts=localhostWelcome to the Geth JavaScript console!instance: Geth/v1.8.3-stable-329ac18e/windows-amd64/go1.10 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 启动私有链之后就可以在控制台中进行账号操作和挖矿等相关操作了 图形化客户端除了使用命令行操作，以太坊还提供了图形界面Mist和Ethereum Wallet，两者功能上相同，下载其中一个即可 下载地址：https://github.com/ethereum/mist/releases/ ，windows建议下载.zip免安装压缩版，解压就可以用了。exe后缀的启动程序时好像会一直卡在“Downloading new node”的启动页面。 国内无法访问的话可以到以太坊爱好者的网站下载：http://ethfans.org/wikis/Wallet-Mirror 安装完成打开程序，第一次打开需要一段时间。客户端默认是同步公链区块的，所以想要在图形界面进入私有链，必须先在命令行启动私有链再打开客户端。进入私有链客户端启动界面的右上角会有PRIVATE-NET标记，进入程序后中间也有Private-net的标记。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>私有链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux以太坊节点搭建]]></title>
    <url>%2F2018%2F11%2F10%2FLinux%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%8A%82%E7%82%B9%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 安装Geth1234root@dserv834-mtl8:~# apt-get install software-properties-commonroot@dserv834-mtl8:~# add-apt-repository -y ppa:ethereum/ethereumroot@dserv834-mtl8:~# apt-get updateroot@dserv834-mtl8:~# apt-get install ethereum 安装后查询到geth版本即为安装成功 12345678910111213root@dserv834-mtl8:~# which geth ###查看geth路径/usr/bin/gethroot@dserv834-mtl8:~# geth versionGethVersion: 1.8.12-stableGit Commit: 37685930d953bcbe023f9bc65b135a8d8b8f1488Architecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.10Operating System: linuxGOPATH=GOROOT=/usr/lib/go-1.10 创建Geth启动/停止脚本查看本地IP地址，得到内网地址为173.209.49.10 12345678910root@dserv834-mtl8:~# ifconfig -aeno1 Link encap:Ethernet HWaddr ac:1f:6b:82:8c:f4 inet addr:173.209.49.10 Bcast:173.209.49.15 Mask:255.255.255.248 inet6 addr: fe80::ae1f:6bff:fe82:8cf4/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:164109642 errors:0 dropped:10 overruns:0 frame:0 TX packets:143189840 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:87852826043 (87.8 GB) TX bytes:35500135072 (35.5 GB) Memory:df200000-df27ffff 创建geth启动脚本starteth.sh，将第二行开始的脚本复制保存，需要修改rpcaddr的ip，datadir可以省略，一般将datadir改为大容量的数据盘目录 1234root@dserv834-mtl8:~# vi starteth.sh #!/bin/bashnohup geth --rpcaddr &quot;173.209.49.10&quot; --rpc --rpccorsdomain=&quot;*&quot; --datadir &quot;/data/ethereum&quot; &gt;&gt; geth.log 2&gt;&amp;1 &amp; 创建geth停止脚本stopeth.sh，将第二行开始的脚本复制保存 123456789root@dserv834-mtl8:~# more stopeth.sh #!/bin/bashPIDS=`ps -ef |grep geth |grep -v grep | awk &apos;&#123;print $2&#125;&apos;`if [ &quot;$PIDS&quot; != &quot;&quot; ]; then kill -9 $PIDSelse echo `date +%F&quot; &quot;%H:%M:%S` &quot;Geth is NOT runing!&quot;fi 配置脚本执行权限 1234root@dserv834-mtl8:~# chmod u+x st*.shroot@dserv834-mtl8:~# ls -la *.sh-rwxr--r-- 1 root root 95 Jul 10 11:41 starteth.sh-rwxr--r-- 1 root root 171 Jul 11 21:49 stopeth.sh 启动geth程序同步区块数据 启动Geth开始同步数据，通过查看geth.log来监控Geth的同步情况 1234567root@dserv834-mtl8:~# ./starteth.shroot@dserv834-mtl8:~# tail -f geth.logINFO [07-11|21:51:06.609] Imported new chain segment blocks=1 txs=55 mgas=7.992 elapsed=368.336ms mgasps=21.697 number=5948083 hash=14c024…a9d1bb cache=267.07mBINFO [07-11|21:51:10.051] Imported new chain segment blocks=1 txs=43 mgas=7.987 elapsed=105.155ms mgasps=75.959 number=5948084 hash=ede212…56e3b8 cache=267.22mBINFO [07-11|21:51:13.530] Imported new chain segment blocks=1 txs=133 mgas=7.961 elapsed=431.951ms mgasps=18.431 number=5948085 hash=533343…c40637 cache=267.59mBINFO [07-11|21:51:17.785] Imported new chain segment blocks=1 txs=51 mgas=7.982 elapsed=304.528ms mgasps=26.211 number=5948086 hash=8918b3…263ea8 cache=268.06mB.......... 一般情况下geth从0开始同步需要3天左右的时间，由服务器的带宽和性能决定，可以购买境外的服务器，如香港的阿里云。 判断同步完成geth在同步的时候，通过geth console查看eth.blockNumber命令查询区块高度，如果得到的结果是0，说明没有同步完成，如果得到最新的区块，说明已经同步到最新区块了。]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>ethereum</tag>
        <tag>节点搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F10%2FHello%20World%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com Hello,大家好，我是本博客的作者陈进坚。欢迎来到我的个人博客，从今天起我将不定时在博客和CSDN同步发布技术文档。主要是关于PHP,Golang和区块链方面的开发技术，欢迎大家关注收藏~ 本站是基于Hexo在github上搭建的免费博客，建站步骤和主题参考： https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/ 除了在本博客和本人的CSDN博客中发布，所有未经授权的文章禁止转载哦，如果大家看到我的文章未授权被转载盗用了请联系我。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>第一篇文章</tag>
        <tag>关于博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[geth常用操作]]></title>
    <url>%2F2018%2F11%2F10%2Fgeth%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 修改钱包密码其中–datadir参数是你的geth目录，这个目录里面包含geth和keystore目录 1$ geth account update &quot;aad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae&quot; --datadir &quot;./data0&quot; 先输入旧的密码解锁 12Unlocking account 0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae | Attempt 1/3Passphrase:旧的密码 再输入两次新的密码，按回车完成 1234Unlocked account address=0xAAd71aAAEF7ce2CA356B9B80d0c385eeCD8eD1AePlease give a new password. Do not forget this password.Passphrase:新的密码Repeat passphrase:再次输入新的密码 进入geth console解锁钱包检验新的密码 1234567$ geth --port 3000 --networkid 15 --datadir=&quot;./data0&quot; --maxpeers=3 --rpc --rpcport 8545 --rpccorsdomain &quot;*&quot; console&gt; personal.unlockAccount(&quot;0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1ae&quot;)Unlock account 0xaad71aaaef7ce2ca356b9b80d0c385eecd8ed1aePassphrase:true 修改默认账号coinbasegeth console中执行 1&gt; miner.setEtherbase(&quot;0xa91Ae941e92eb6Fa78FE0d8215F01cbE6b7C014c&quot;) 覆盖交易当发送的交易还没有交易完成时，以太坊是可以用新的交易将那笔未完成的交易覆盖的，当交易的数量为0时表示将交易覆盖取消。当然，第二笔交易的gasPrice需要比被覆盖掉的高。 nonce的作用：每个钱包地址发送都会产生一个nonce值，默认从0开始，这个地址每发送一笔交易nonce+1,类似数据库的自增id,覆盖交易就是发送相同nonce的一笔交易，将该笔交易覆盖。当nonce比之前交易成功的nonce小，交易会被直接拒绝；当nonce比之前交易成功的nonce大2或以上，就是两笔nonce不连续，那么交易会一直等待。比如说上一笔交易成功的交易nonce为4，这次交易的nonce为6，那么在nonce为5的交易完成之后，nonce为6以及大于6的交易都会暂停，不会交易成功。 1.查询该钱包当前的nonce 12&gt; eth.getTransactionCount(&apos;0xa94183a1d6982a9703791Ec1DfF0093746030A78&apos;)1827 说明从nonce为0到1826的交易都成功了 2.发送指定nonce的交易 假设nonce为1827的交易已经发送，但是未交易完成，我们可以将这笔交易覆盖 1&gt;eth.sendTransaction(&#123;from:eth.coinbase,to:&quot;0x8E9e5Db2Dd8B468CC9edC1f72Dd2948828d5285a&quot;,value:web3.toWei(0.01,&apos;ether&apos;),gasPrice:web3.toWei(0.000000004,&apos;ether&apos;),nonce:1827&#125;) 如果1826和1828之间缺了一笔1827，造成交易无法继续，可以用同样的方法发送交易补全nonce为连续的数，当然发送的币量可以为0 Unable to attach to remote geth问题如果使用geth attach命令打开控制台出现：Unable to attach to remote geth: dial unix \/home\/www\/.ethereum\/geth.ipc: connect: permission denied”]，一般为权限问题， 输入下面的命令修改权限为www即可(LNMP环境)，geth.ipc的路径根据实际路径修改： 12cd /ethdb/ethereum/chown -R www:www geth.ipc]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间与时间戳的获取和转换]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 获取时间戳需要 import “time” 包 12345678910//获取当前时间戳，单位s,打印结果:1491888244timeUnix:=time.Now().Unix() //获取当前时间戳，单位纳秒,打印结果：1491888244752784461timeUnixNano:=time.Now().UnixNano() //获取指定时间的时间戳loc, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;) //设置时区timeStr, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, &quot;2018-07-11 15:07:58&quot;, loc) //2006-01-02 15:04:05是转换的格式，如php的&quot;Y-m-d H:i:s&quot;，&quot;2018-07-11 15:07:58&quot;才是真正要转换的时间fmt.Println(timeStr.Unix()) //打印结果：1531292878 获取时间需要 import “time” 包 123456789t := time.Now() //2018-10-22 06:59:39.399239964 +0000 UTCy := t.Year() //年m := t.Month() //月d := t.Day() //日h := t.Hour() //小时i := t.Minute() //分钟s := t.Second() //秒fmt.Println(y, m, d, h, i, s) //2018 July 11 15 24 59]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP开发规范]]></title>
    <url>%2F2018%2F11%2F10%2FPHP%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[本文作者：陈进坚博客地址：https://jian1098.github.ioCSDN博客：https://blog.csdn.net/c_jian简书：https://www.jianshu.com/u/8ba9ac5706b6联系方式：jian1098@qq.com 一、摘要&emsp;&emsp;这是一份旨在增强团队的开发协作，提高代码质量和打造开发基石的编码风格规范。当一个团队开始指定并实行编码规范的话，错误就会变得更加显而易见。如果一段特定的代码不符合规范的话，它有可能只是代码风格错误，而也有可能会是 bug，更可能出现安全问题。早期指定规范就使得代码审核得以更好的开展，并且可以更精确的地定位到错误。只要开发者们能够保证源代码源文件都严格遵循规范，那接下来的维护工作就可以变得轻松简单。总之，我们的目标就是遵循同一套编码规范，不管有多少人共同参与同一项目，都可以确保每一行代码都像是同一个人编写的，每一个功能都是安全的。 二、PHP相关命名规范2.1 方法命名&emsp;&emsp;方法，指的是在类中定义的函数，方法的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 getUserName( )，_parseType( )，通常下划线开头的方法属于私有方法； 2.2 函数命名&emsp;&emsp;函数是指不在类中定义的函数，例如在公共文件中的函数。函数的命名使用小写字母和下划线的方式，例如 get_client_ip( )； 2.3 变量（属性）命名&emsp;&emsp;变量，也叫属性。属性的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 tableName、_instance，通常下划线开头的属性属于私有属性； 2.4 常量命名&emsp;&emsp;常量以大写字母和下划线命名，例如 HAS_ONE和 MANY_TO_MANY； 2.5 配置参数命名&emsp;&emsp;配置参数以大写字母和下划线命名，例如 HTML_CACHE_ON = 1； 三、数据库相关命名规范3.1 数据库命名&emsp;&emsp;数据库的命名一般采用小写字母命名，如 testdb; 3.2 数据表命名&emsp;&emsp;数据表命名格式为 表前缀+下划线（_）+表名 组合方式命名。同一数据库表前缀相同，且使用小写字母命名，表名使用小写字母和下划线命名。例如 wll_setting_record，其中wll为前缀，setting_record为表名。 3.3 字段命名&emsp;&emsp;字段的命名采用小写字母和下划线命名，如 coin_type。 四、禁止使用的命名方式4.1 无意义的命名&emsp;&emsp;例如：$abcd、qqqqqqq()、test1111111等，命名应该使用对应的英文翻译； 4.2 拼音命名&emsp;&emsp;例如添加用户（tjyh）或中英混合的（tjUser），如果使用这种方式，其他开发人员会很难看得懂，加大维护难度。 4.3 单字母命名&emsp;&emsp;ThinkPHP中封装了很多名称为单字母的快捷方法，例如A( )、C( )、M( )。如果再定义可能会发生冲突。 五、注释规范5.1 方法和函数&emsp;&emsp;在方法和函数的上一行必须用双斜线注释注明该方法或函数的功能，在难以理解的代码语句后面适当添加注释说明，例如：123456789101112131415161718192021// 短信宝短信 http://www.smsbao.com/public function smsbao($username, $password, $moble, $content)&#123; $url = &apos;http://api.smsbao.com/sms?u=&apos; . $username . &apos;&amp;p=&apos; . $password . &apos;&amp;m=&apos; . $moble . &apos;&amp;c=&apos; . $content; if (function_exists(&apos;file_get_contents&apos;)) &#123; $file_contents = file_get_contents($url); &#125; else &#123; $ch = curl_init(); $timeout = 5; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout); $file_contents = curl_exec($ch); curl_close($ch); &#125; if ($file_contents &gt; 0) &#123; return [$file_contents]; // 失败 &#125; else &#123; return [$file_contents, 1]; //成功 &#125;&#125; 5.2 配置参数&emsp;&emsp;在配置文件中的参数设置必须注明变量含义，例如：12345&apos;DB_TYPE&apos; =&gt; &apos;mysql&apos;, // 数据库类型&apos;DB_HOST&apos; =&gt; &apos;localhost&apos;, // 服务器地址&apos;DB_NAME&apos; =&gt; &apos;wlldb&apos;, // 数据库名&apos;DB_USER&apos; =&gt; &apos;root&apos;, // 用户名&apos;DB_PWD&apos; =&gt; &apos;root&apos;, // 密码 六、编码风格规范6.1 禁止出现多行空格&emsp;&emsp;如果不是特殊需要，在代码文件中禁止出现多行空格，例如下面这种是不允许的：12345678910//公共方法public function common()&#123; $name=&apos;tom&apos;; //定义姓名 $this-&gt;assign(&apos;name&apos;,$name); $this-&gt;display();&#125; 6.2 缩进&emsp;&emsp;代码中需要适当的缩进，否则会加大维护难度。 6.3 目录结构&emsp;&emsp;一般框架都是有默认的目录结构，非特殊情况不允许修改目录结构，例如thinkphp默认的是MVC架构的目录结构，避免由于更改目录结构带来的维护困难。Controller文件放在Controller目录 中，Model文件放在Model目录中，View文件放在View目录中，不要随意更改目录的位置和目录名称。 七、安全7.1.1 输入框&emsp;&emsp;所有的输入框请设置最大长度，必填项请做必填的限制。例如帐号CHN00000001,只能输入11位，那么最大输入长度只能为11，并且添加required=”required”属性。 7.1.2 文本编辑器&emsp;&emsp;前台页面尽量不要使用富文本编辑器，因为富文本编辑器可以输入代码，有很大的安全隐患。如果要使用，必须对提交内容进行过滤，例如使用htmlspecialchars()进行过滤。 7.2 后台接收参数&emsp;&emsp;PHP从表单获取url中获取参数必须进行字段类型判断。例如接收数字的参数不能含有其他字符，只能是数字，建议编写公共的检查接收post和get参数的函数，对每一个参数值进行验证，防止注入恶意代码。&emsp;&emsp;接收长篇内容的变量，例如留言内容等变量时，必须进行特殊字符的过滤操作。比如strip_tags()、htmlspecialchars()、htmlentities()等函数可以起作用，防止用户注入恶意代码进行跨站脚本攻击。 7.3 数据库查询&emsp;&emsp;数据库查询语句禁止直接使用sql语句和传递的参数直接执行，例如下面这种的写法是禁止使用的：1234$id = 1;$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where(&apos;id=&apos;.$id)-&gt;select(); //错误写法1$User-&gt;where(&quot;id=$id&quot;)-&gt;select(); //错误写法2 &emsp;&emsp;如果传递过来的参数含有SQL注入代码，这两种写法都是非常危险的。正确的写法有以下两种：（1）数组条件，例如：123$where[&apos;id&apos;] = 1;$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where($where)-&gt;select(); 或者12$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where([&apos;id&apos;=&gt;1])-&gt;select(); （2）预处理机制，例如：12$User = M(&quot;User&quot;); // 实例化User对象$User-&gt;where(&quot;id=%d&quot;,$id)-&gt;select(); 7.4 权限控制&emsp;&emsp;凡是需要登录之后才可以访问的页面加载页面之前必须做好登录检测，登录超时的必须重新登录。需要权限访问的页面和功能必须做好权限控制和检测。 7.5 越权访问&emsp;&emsp;比如邮件列表的页面 http://119.28.56.83/user/xq/id/5 ，只需要修改最后面的邮件id就可以直接访问的，必须加入当前用户判断，只能查看自己的邮件，禁止越权访问。 7.6 数据导出&emsp;&emsp;数据的导出和下载必须做好登录状态验证和权限的控制，没有权限或没有登录的禁止下载导出。 7.7 防暴力破解&emsp;&emsp;暴力破解是指使用数据字典等枚举方式逐个帐号进行密码的尝试破解，为了防止这种破解，在登录、注册、找回密码等页面必须设置好图形验证码或者其他验证，最好是做好错误次数的限制，例如密码输错5次，一个小时内禁止登录等。 7.8 短信邮件安全&emsp;&emsp;用到发送短信和发送邮件的页面，必须设置图形验证码，点击发送之前，验证图形验证码正确后再发送。最好限制每个手机号每天的发送数量。 7.9 密码明文传输&emsp;&emsp;一般在前端页面表单提交的时候，用户输入密码是明文的。在服务器没有配置SLL证书(https)的情况下，必须先进行加密操作再提交，参数传递到后台接收后再进行解密操作。服务器配置SLL证书(https)可以自动进行加密传输，安全性更高。 7.10 使用外部文件&emsp;&emsp;在前端页面中，禁止引入其他网站的静态文件（javascript、css、网络图片等），如果需要用到，必须下载到本地，使用相对地址引入文件。使用本地静态文件的优点：加载更快，安全，确保不失效。 7.11 密码安全&emsp;&emsp;禁止将明文密码存储在数据库中，所有密码必须加密处理，防止用户数据被导出造成密码泄露。禁止在日志、调试信息文件、cookies中记录密码口令、银行账号、通信内容等敏感数据。为了保障帐号的安全，所有密码的长度强制限制在6位以上。 八、并发和大流量处理8.1 重复提交&emsp;&emsp;为了防止用户在提交表单时重复提交，表单必须设置提交验证。例如商城提交订单时，必须防止用户重复提交。Thinkphp框架中提供表单令牌的功能可以防止重复提交，原生php也可以在打开页面前生成token，并保存在session，然后将token传递到页面表单字段，在表单提交时将token一起提交，在后台接收时验证token，验证后销毁session的保存的token。 8.2 session&emsp;&emsp;一次性验证的session使用后必须销毁，例如短信验证，表单验证等，防止一次性session被重复利用，例如在用户在注册时如果不销毁短信验证码session，用户可以用同一个短信验证码注册多个账号。 8.3 并发&emsp;&emsp;并发处理会经常碰到，例如商城秒杀功能，如果不做好并发处理，那么同一件商品江湖被多个用户购买。并发的处理方案可以考虑以下方案：（1）锁表操作，缺点是并发数比较大的时候回造成系统卡顿。（2）队列（3）负载均衡（4）数据库读写分离 (5) 使用Nginx作为http服务器 8.4 缓存&emsp;&emsp;对于经常需要访问的数据库数据，可以使用缓存来提高访问速度，读取缓存文件数据币数据库查询要快得多，主要缓存技术有：（1）Thinkphp自带的S()方法（2）文件读写，这个方法主意数据的加密确保安全性（3）Memcached]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
</search>
